<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Advanced Sampling Plan Analyzer - Unified Layout</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
    :root {
        /* Default theme: Dark Teal */
        --bg: #0f1c26; --panel: #1c2a36; --panel-2: #111c26; --border: #405466; --text: #e6e9ee; --muted: #9fb0bf;
        --primary: #1783FF; --primary-2: #0e61bf; --card: #ecf0f1; --card-text: #2c3e50;
        --radius: 12px; --gap: 16px; --left: 360px; --chart-h: 650px;
        
        /* Gradient backgrounds for themes */
        --bg-gradient-1: #223649;
        --bg-gradient-2: #0f1c26;
        --panel-gradient-1: #1c2a36;
        --panel-gradient-2: #182531;
        
        /* RGB values for rgba() CSS functions */
        --primary-rgb: 23, 131, 255;
        --primary-2-rgb: 14, 97, 191;
    }

    /* Light Theme */
    [data-theme="light"] {
        --bg: #f8f9fa; --panel: #ffffff; --panel-2: #f1f3f4; --border: #adb5bd; --text: #212529; --muted: #495057;
        --primary: #0d6efd; --primary-2: #0b5ed7; --card: #ffffff; --card-text: #212529;
        --bg-gradient-1: #e9ecef;
        --bg-gradient-2: #f8f9fa;
        --panel-gradient-1: #ffffff;
        --panel-gradient-2: #f8f9fa;
        --primary-rgb: 13, 110, 253;
        --primary-2-rgb: 11, 94, 215;
    }

    /* Dark Gray Theme */
    [data-theme="dark-gray"] {
        --bg: #1a1a1a; --panel: #2d2d2d; --panel-2: #242424; --border: #404040; --text: #e0e0e0; --muted: #a0a0a0;
        --primary: #bb86fc; --primary-2: #9c64e2; --card: #ecf0f1; --card-text: #2c3e50;
        --bg-gradient-1: #333333;
        --bg-gradient-2: #1a1a1a;
        --panel-gradient-1: #2d2d2d;
        --panel-gradient-2: #262626;
        --primary-rgb: 187, 134, 252;
        --primary-2-rgb: 156, 100, 226;
    }

    /* Dark Blue Theme */
    [data-theme="dark-blue"] {
        --bg: #0d1421; --panel: #1e2a3a; --panel-2: #151f2e; --border: #2c3e50; --text: #ecf0f1; --muted: #95a5a6;
        --primary: #3498db; --primary-2: #2980b9; --card: #ecf0f1; --card-text: #2c3e50;
        --bg-gradient-1: #2c3e50;
        --bg-gradient-2: #0d1421;
        --panel-gradient-1: #1e2a3a;
        --panel-gradient-2: #1a252f;
        --primary-rgb: 52, 152, 219;
        --primary-2-rgb: 41, 128, 185;
    }

    /* Light Blue Theme */
    [data-theme="light-blue"] {
        --bg: #e3f2fd; --panel: #ffffff; --panel-2: #f3f9ff; --border: #757575; --text: #0d47a1; --muted: #424242;
        --primary: #2196f3; --primary-2: #1976d2; --card: #ffffff; --card-text: #0d47a1;
        --bg-gradient-1: #bbdefb;
        --bg-gradient-2: #e3f2fd;
        --panel-gradient-1: #ffffff;
        --panel-gradient-2: #f3f9ff;
        --primary-rgb: 33, 150, 243;
        --primary-2-rgb: 25, 118, 210;
    }

    /* Light Yellow Theme */
    [data-theme="light-yellow"] {
        --bg: #fffef7; --panel: #ffffff; --panel-2: #fefdf0; --border: #757575; --text: #3e2723; --muted: #5d4037;
        --primary: #f39c12; --primary-2: #e67e22; --card: #ffffff; --card-text: #3e2723;
        --bg-gradient-1: #fff8dc;
        --bg-gradient-2: #fffef7;
        --panel-gradient-1: #ffffff;
        --panel-gradient-2: #fefdf0;
        --primary-rgb: 243, 156, 18;
        --primary-2-rgb: 230, 126, 34;
    }

    /* Light Pink Theme */
    [data-theme="light-pink"] {
        --bg: #fce4ec; --panel: #ffffff; --panel-2: #f8e8ee; --border: #757575; --text: #4a148c; --muted: #6a1b9a;
        --primary: #e91e63; --primary-2: #c2185b; --card: #ffffff; --card-text: #4a148c;
        --bg-gradient-1: #f8bbd9;
        --bg-gradient-2: #fce4ec;
        --panel-gradient-1: #ffffff;
        --panel-gradient-2: #f8e8ee;
        --primary-rgb: 233, 30, 99;
        --primary-2-rgb: 194, 24, 91;
    }
    
    /* Light theme button adjustments */
    [data-theme="light"] .btn,
    [data-theme="light-blue"] .btn,
    [data-theme="light-yellow"] .btn,
    [data-theme="light-pink"] .btn {
        background: linear-gradient(135deg, 
            rgba(0,0,0,0.05), 
            rgba(0,0,0,0.02));
        box-shadow: 
            0 2px 8px rgba(0,0,0,0.1),
            inset 0 1px 0 rgba(255,255,255,0.8),
            inset 0 -1px 0 rgba(0,0,0,0.1);
        text-shadow: none;
    }
    
    [data-theme="light"] .btn:hover,
    [data-theme="light-blue"] .btn:hover,
    [data-theme="light-yellow"] .btn:hover,
    [data-theme="light-pink"] .btn:hover {
        background: linear-gradient(135deg, 
            rgba(0,0,0,0.08), 
            rgba(0,0,0,0.04));
        box-shadow: 
            0 4px 12px rgba(0,0,0,0.15),
            inset 0 1px 0 rgba(255,255,255,0.9),
            inset 0 -1px 0 rgba(0,0,0,0.15);
    }
    
    /* Light theme Distribution Types button text contrast fix */
    [data-theme="light"] .btn[data-dist].primary,
    [data-theme="light-blue"] .btn[data-dist].primary,
    [data-theme="light-yellow"] .btn[data-dist].primary,
    [data-theme="light-pink"] .btn[data-dist].primary {
        color: var(--text) !important;
        text-shadow: none !important;
    }
    
    /* Light theme glass button text contrast fix */
    [data-theme="light"] .glass-button,
    [data-theme="light-blue"] .glass-button,
    [data-theme="light-yellow"] .glass-button,
    [data-theme="light-pink"] .glass-button {
        color: var(--text) !important;
        text-shadow: none !important;
    }
    
    /* Light theme primary button text contrast fix */
    [data-theme="light"] .btn.primary,
    [data-theme="light-blue"] .btn.primary,
    [data-theme="light-yellow"] .btn.primary,
    [data-theme="light-pink"] .btn.primary {
        color: var(--text) !important;
        text-shadow: none !important;
    }
    
    /* Light theme primary button hover text contrast fix */
    [data-theme="light"] .btn.primary:hover,
    [data-theme="light-blue"] .btn.primary:hover,
    [data-theme="light-yellow"] .btn.primary:hover,
    [data-theme="light-pink"] .btn.primary:hover {
        color: var(--text) !important;
        text-shadow: none !important;
    }
    
    /* Light theme tab adjustments */
    [data-theme="light"] .tab,
    [data-theme="light-blue"] .tab,
    [data-theme="light-yellow"] .tab,
    [data-theme="light-pink"] .tab {
        background: linear-gradient(135deg, 
            rgba(0,0,0,0.08), 
            rgba(0,0,0,0.04));
        text-shadow: none;
        color: var(--text);
    }
    
    [data-theme="light"] .tab:hover,
    [data-theme="light-blue"] .tab:hover,
    [data-theme="light-yellow"] .tab:hover,
    [data-theme="light-pink"] .tab:hover {
        background: linear-gradient(135deg, 
            rgba(0,0,0,0.12), 
            rgba(0,0,0,0.06));
    color: var(--text);
    text-shadow: none;
    }
    
    /* Light theme active tab contrast fix */
    [data-theme="light"] .tab.active,
    [data-theme="light-blue"] .tab.active,
    [data-theme="light-yellow"] .tab.active,
    [data-theme="light-pink"] .tab.active {
        color: var(--text);
        text-shadow: none;
        border: 1px solid var(--border);
    }
    
    /* Light theme active tab hover contrast fix */
    [data-theme="light"] .tab.active:hover,
    [data-theme="light-blue"] .tab.active:hover,
    [data-theme="light-yellow"] .tab.active:hover,
    [data-theme="light-pink"] .tab.active:hover {
        color: var(--text);
        text-shadow: none;
        box-shadow: 0 8px 18px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.4);
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: 'Noto Sans TC', 'Montserrat', system-ui, -apple-system, sans-serif; color: var(--text); background: radial-gradient(1200px 800px at 30% -10%, var(--bg-gradient-1) 0%, var(--bg-gradient-2) 60%); transition: background 0.3s ease, color 0.3s ease; }
    .app { max-width: 1200px; margin: 0 auto; padding: 24px; }
    header { text-align: center; margin-bottom: 12px; }
    header h1 { margin: 0 0 6px 0; font-size: 2rem; }
    header p { margin: 0; color: var(--muted); font-size: 0.75rem; opacity: 0.7; letter-spacing: 0.3px; }

    /* Layout wrapper to place sidebar (tabs) left of pages */
    .main-layout { display: flex; gap: 16px; align-items: flex-start; }
    .sidebar { width: 260px; flex: 0 0 260px; position: sticky; top: 12px; align-self: flex-start; margin-top: 120px; }
    .pages { flex: 1 1 auto; min-width: 0; }

    /* Tabs with Liquid Glass Effect (vertical in sidebar) */
    .tabs { 
        display: flex; 
        flex-direction: column;
        gap: 10px; 
        justify-content: flex-start; 
        margin: 0; 
        padding: 0;
        background: none;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
        border-radius: 0;
        border: none;
        box-shadow: none;
    }
    
    .tab { 
        background: linear-gradient(135deg, 
            rgba(255,255,255,0.15), 
            rgba(255,255,255,0.08));
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        color: var(--text); 
        font-weight: 600;
        font-size: 0.9rem;
        padding: 15px 18px;
        text-shadow: 0 1px 3px rgba(0,0,0,0.3); 
        border-radius: 8px; 
        cursor: pointer; 
        box-shadow: 
            0 4px 20px rgba(0,0,0,0.1),
            inset 0 1px 0 rgba(255,255,255,0.3);
        border: 1px solid rgba(255,255,255,0.2);
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
        white-space: nowrap; 
        text-align: center;
    }

    /* Ensure tabs fill sidebar width and content width remains unchanged by adding sidebar width to container */
    .tabs .tab { width: 100%; display: flex; align-items: center; justify-content: center; }
    .app { max-width: calc(1200px + 260px + 16px); }
    
    .tab::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, 
            transparent, 
            rgba(255,255,255,0.4), 
            transparent);
        transition: left 0.6s ease;
    }
    
    .tab:hover::before {
        left: 100%;
    }
    
    .tab:hover {
        transform: translateY(-3px) scale(1.05);
        background: linear-gradient(135deg, 
            rgba(52, 152, 219, 0.25), 
            rgba(52, 152, 219, 0.15));
        box-shadow: 
            0 8px 30px rgba(52, 152, 219, 0.3),
            inset 0 1px 0 rgba(255,255,255,0.4);
        color: #ffffff;
        text-shadow: 0 1px 3px rgba(52, 152, 219, 0.8);
    }
    
    .tab.active { 
        background: linear-gradient(135deg, 
            rgba(52, 152, 219, 0.35), 
            rgba(52, 152, 219, 0.2));
        box-shadow: 
            0 6px 25px rgba(52, 152, 219, 0.4),
            inset 0 1px 0 rgba(255,255,255,0.5),
            inset 0 -1px 0 rgba(41, 128, 185, 0.3);
        color: #ffffff;
        text-shadow: 0 1px 3px rgba(52, 152, 219, 0.8);
        transform: translateY(-2px);
        border: 1px solid rgba(52, 152, 219, 0.3);
    }
    
    .tab.active::after {
        content: '';
        position: absolute;
        bottom: 2px;
        left: 50%;
        transform: translateX(-50%);
        width: 60%;
        height: 2px;
        background: linear-gradient(90deg, 
            transparent, 
            rgba(52, 152, 219, 0.8), 
            transparent);
        border-radius: 1px;
    }

    /* Ensure active tab shows the same hover animation/effects */
    .tab.active:hover::before { left: 100%; }
    .tab.active:hover {
        transform: translateY(-3px) scale(1.05);
        background: linear-gradient(135deg, rgba(52,152,219,0.25), rgba(52,152,219,0.15));
        box-shadow: 0 8px 30px rgba(52,152,219,0.3), inset 0 1px 0 rgba(255,255,255,0.4);
        color: #ffffff;
        text-shadow: 0 1px 3px rgba(52,152,219,0.8);
    }

    /* Liquid Glass Button Effect */
    .glass-button {
        background: linear-gradient(135deg, 
            rgba(255,255,255,0.2), 
            rgba(255,255,255,0.1)) !important;
        backdrop-filter: blur(20px) !important;
        -webkit-backdrop-filter: blur(20px) !important;
        border: 1px solid rgba(255,255,255,0.3) !important;
        border-radius: 20px !important;
        padding: 14px 24px !important;
        font-size: 1rem !important;
        font-weight: 600 !important;
        color: #ffffff !important;
        text-shadow: 0 1px 3px rgba(0,0,0,0.6) !important;
        box-shadow: 
            0 8px 32px rgba(0,0,0,0.1),
            inset 0 1px 0 rgba(255,255,255,0.4),
            0 0 0 1px rgba(102, 126, 234, 0.2) !important;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1) !important;
        position: relative !important;
        overflow: hidden !important;
        cursor: pointer !important;
    }
    
    .glass-button::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, 
            transparent, 
            rgba(255,255,255,0.5), 
            transparent);
        transition: left 0.6s ease;
        z-index: 1;
    }
    
    .glass-button:hover::before {
        left: 100%;
    }
    
    .glass-button:hover {
        transform: translateY(-4px) scale(1.05) !important;
        background: linear-gradient(135deg, 
            rgba(102, 126, 234, 0.3), 
            rgba(118, 75, 162, 0.2)) !important;
        box-shadow: 
            0 12px 40px rgba(102, 126, 234, 0.4),
            inset 0 1px 0 rgba(255,255,255,0.5),
            0 0 0 2px rgba(102, 126, 234, 0.3) !important;
        color: #667eea !important;
    }
    
    .glass-button:active {
        transform: translateY(-2px) scale(1.02) !important;
        box-shadow: 
            0 6px 20px rgba(102, 126, 234, 0.3),
            inset 0 1px 0 rgba(255,255,255,0.3) !important;
    }
    
    .glass-button span, .glass-button * {
        position: relative;
        z-index: 2;
    }

    /* Page header card */
    .page-header { background: var(--card); color: var(--card-text); border-radius: 10px; padding: 16px 18px; margin: 8px 0 14px 0; text-align: center; }
    .page-header h2 { margin: 0 0 6px 0; font-size: 1.35rem; }
    .page-header p { margin: 0; color: var(--card-text); opacity: 0.7; }

    /* Two-column content */
    .content { display: flex; gap: var(--gap); }
    .left { width: var(--left); flex-shrink: 0; display: flex; flex-direction: column; gap: var(--gap); height: var(--chart-h); overflow-y: auto; padding-right: 6px; }
    /* subtle scrollbar */
    .left::-webkit-scrollbar { width: 8px; }
    .left::-webkit-scrollbar-thumb { background: rgba(199,202,207,0.28); border-radius: 6px; }
    .left::-webkit-scrollbar-track { background: transparent; }
    .panel { background: linear-gradient(145deg, var(--panel-gradient-1), var(--panel-gradient-2)); border: 1px solid var(--border); border-radius: var(--radius); padding: 16px; transition: background 0.3s ease, border-color 0.3s ease; }
    .panel h3 { margin: 0 0 10px 0; font-size: 1rem; }
    .parameters { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .group label { display: block; font-size: 0.85rem; color: var(--muted); margin-bottom: 6px; }
    .group input, .group select { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--panel-2); color: var(--text); font-weight: 700; text-align: center; box-shadow: inset 0 2px 0 rgba(255,255,255,0.04), inset 0 -2px 0 rgba(0,0,0,0.1); transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease; }
    
    /* Theme selector specific styling */
    .theme-selector {
        background: var(--panel-2) !important;
        border: 1px solid var(--border) !important;
        color: var(--text) !important;
        font-size: 0.9rem !important;
        font-weight: 600 !important;
        cursor: pointer;
    }
    .theme-selector:focus {
        outline: 2px solid var(--primary);
        outline-offset: 2px;
    }
    .theme-selector option {
        background: var(--panel);
        color: var(--text);
        padding: 8px;
    }
    .btn { 
        position: relative; 
        color: var(--text);
        text-shadow: 0 1px 2px rgba(0,0,0,0.3); 
        border-radius: 8px; 
        padding: 10px 12px; 
        font-weight: 600; 
        cursor: pointer; 
        border: 1px solid var(--border);
        background: linear-gradient(135deg, 
            rgba(255,255,255,0.18), 
            rgba(255,255,255,0.08));
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        box-shadow: 
            0 4px 20px rgba(0,0,0,0.08),
            inset 0 1px 0 rgba(255,255,255,0.3),
            inset 0 -1px 0 rgba(0,0,0,0.05);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        overflow: hidden;
    }
    
    .btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, 
            transparent, 
            rgba(255,255,255,0.3), 
            transparent);
        transition: left 0.5s ease;
    }
    
    .btn:hover::before {
        left: 100%;
    }
    
    .btn:hover { 
        transform: translateY(-2px) scale(1.02);
        background: linear-gradient(135deg, 
            rgba(255,255,255,0.25), 
            rgba(255,255,255,0.12));
        box-shadow: 
            0 6px 25px rgba(0,0,0,0.12),
            inset 0 1px 0 rgba(255,255,255,0.4),
            inset 0 -1px 0 rgba(0,0,0,0.08);
        color: #34495e;
    }
    
    .btn:active { 
        transform: translateY(-1px) scale(1.01); 
        box-shadow: 
            0 3px 15px rgba(0,0,0,0.1),
            inset 0 1px 0 rgba(255,255,255,0.2);
    }
    
    .btn.primary { 
        background: linear-gradient(135deg, 
            rgba(var(--primary-rgb, 52, 152, 219), 0.3), 
            rgba(var(--primary-rgb, 52, 152, 219), 0.15));
        color: #ffffff;
        text-shadow: 0 1px 3px rgba(var(--primary-rgb, 52, 152, 219), 0.8);
        border: 1px solid rgba(var(--primary-rgb, 52, 152, 219), 0.3);
        box-shadow: 
            0 4px 20px rgba(var(--primary-rgb, 52, 152, 219), 0.2),
            inset 0 1px 0 rgba(255,255,255,0.4),
            inset 0 -1px 0 rgba(var(--primary-2-rgb, 41, 128, 185), 0.2);
    }
    
    .btn.primary:hover {
        background: linear-gradient(135deg, 
            rgba(var(--primary-rgb, 52, 152, 219), 0.4), 
            rgba(var(--primary-rgb, 52, 152, 219), 0.2));
        box-shadow: 
            0 6px 25px rgba(var(--primary-rgb, 52, 152, 219), 0.3),
            inset 0 1px 0 rgba(255,255,255,0.5),
            inset 0 -1px 0 rgba(var(--primary-2-rgb, 41, 128, 185), 0.3);
        color: #ffffff;
        text-shadow: 0 1px 3px rgba(var(--primary-rgb, 52, 152, 219), 0.8);
    }
    .btn-row { display: flex; gap: 8px; flex-wrap: wrap; }
    
    /* Error text styling with theme-aware contrast */
    .error-text { 
        margin-top: 8px; 
        font-size: 0.9rem; 
        display: none; 
        color: var(--error-color, #f5b7b1);
    }
    
    /* Light theme error text color for better contrast */
    [data-theme="light"] .error-text,
    [data-theme="light-blue"] .error-text,
    [data-theme="light-yellow"] .error-text,
    [data-theme="light-pink"] .error-text {
        color: #d63031;
    }
    
    /* Dark theme error text color */
    [data-theme="dark-teal"] .error-text,
    [data-theme="dark-gray"] .error-text,
    [data-theme="dark-blue"] .error-text {
        color: #f5b7b1;
    }
    
    /* Info text styling with theme-aware contrast */
    .info-text { 
        margin-top: 6px; 
        font-size: 0.9rem; 
        display: none; 
        color: var(--text);
        opacity: 0.8;
    }
    
    /* Distribution Types specific styling */
    .btn-row .btn[data-dist] {
        flex: 1;
        min-width: 0;
        font-size: 0.85rem;
        padding: 10px 8px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    /* Ensure Distribution Types row doesn't wrap */
    .panel h3 + .btn-row {
        flex-wrap: nowrap;
    }

    /* Per-distribution button colors with liquid glass effect */
    /* Inactive distribution buttons use default gray styling (same as Clear All) */
    .btn[data-dist="hyper"].primary { 
        background: linear-gradient(135deg, 
            rgba(241,196,15,0.35), 
            rgba(241,196,15,0.2)); 
        color: #ffffff;
        text-shadow: 0 1px 3px rgba(241, 196, 15, 0.8); 
        border: 1px solid rgba(241,196,15,0.5);
        box-shadow: 
            0 4px 20px rgba(241,196,15,0.25),
            inset 0 1px 0 rgba(255,255,255,0.4),
            inset 0 -1px 0 rgba(241,196,15,0.2);
    }
    .btn[data-dist="hyper"].primary:hover {
        background: linear-gradient(135deg, 
            rgba(241,196,15,0.45), 
            rgba(241,196,15,0.25));
        box-shadow: 
            0 6px 25px rgba(241,196,15,0.35),
            inset 0 1px 0 rgba(255,255,255,0.5),
            inset 0 -1px 0 rgba(241,196,15,0.3);
    }

    .btn[data-dist="binom"].primary { 
        background: linear-gradient(135deg, 
            rgba(46,204,113,0.35), 
            rgba(46,204,113,0.2)); 
        color: #ffffff;
        text-shadow: 0 1px 3px rgba(46, 204, 113, 0.8); 
        border: 1px solid rgba(46,204,113,0.5);
        box-shadow: 
            0 4px 20px rgba(46,204,113,0.25),
            inset 0 1px 0 rgba(255,255,255,0.4),
            inset 0 -1px 0 rgba(46,204,113,0.2);
    }
    .btn[data-dist="binom"].primary:hover {
        background: linear-gradient(135deg, 
            rgba(46,204,113,0.45), 
            rgba(46,204,113,0.25));
        box-shadow: 
            0 6px 25px rgba(46,204,113,0.35),
            inset 0 1px 0 rgba(255,255,255,0.5),
            inset 0 -1px 0 rgba(46,204,113,0.3);
    }

    .btn[data-dist="pois"].primary { 
        background: linear-gradient(135deg, 
            rgba(231,76,60,0.35), 
            rgba(231,76,60,0.2)); 
        color: #ffffff;
        text-shadow: 0 1px 3px rgba(231, 76, 60, 0.8); 
        border: 1px solid rgba(231,76,60,0.5);
        box-shadow: 
            0 4px 20px rgba(231,76,60,0.25),
            inset 0 1px 0 rgba(255,255,255,0.4),
            inset 0 -1px 0 rgba(231,76,60,0.2);
    }
    .btn[data-dist="pois"].primary:hover {
        background: linear-gradient(135deg, 
            rgba(231,76,60,0.45), 
            rgba(231,76,60,0.25));
        box-shadow: 
            0 6px 25px rgba(231,76,60,0.35),
            inset 0 1px 0 rgba(255,255,255,0.5),
            inset 0 -1px 0 rgba(231,76,60,0.3);
    }

    .right { flex: 1 1 auto; min-width: 0; display: flex; flex-direction: column; }
    .chart-card { background: var(--panel-2); border: 1px solid var(--border); border-radius: var(--radius); padding: 16px; display: flex; flex-direction: column; gap: 10px; height: var(--chart-h); }
    .chart-toolbar { display: flex; gap: 8px; align-items: center; }
    .chart { flex: 1 1 auto; min-height: 0; height: 100%; aspect-ratio: 4 / 3; width: auto; max-width: 100%; margin: 0 auto; }
    .chart canvas { width: 100% !important; height: 100% !important; }

    /* Sections */
    .section { display: none; }
    .section.active { display: block; }

    @media (max-width: 900px) {
        .content { flex-direction: column; }
        .left { width: 100%; height: auto; overflow: visible; padding-right: 0; }
        .chart-card { height: 420px; }
    }

    /* Tutorial Styles */
    .tutorial-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .tutorial-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        -webkit-backdrop-filter: blur(5px);
        backdrop-filter: blur(5px);
    }
    
    .tutorial-content {
        position: relative;
        background: linear-gradient(145deg, var(--panel), #1a2b3a);
        border: 1px solid var(--border);
        border-radius: 20px;
        width: 90%;
        max-width: 800px;
        max-height: 90vh;
        overflow: hidden;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        animation: tutorialSlideIn 0.4s ease-out;
    }
    
    @keyframes tutorialSlideIn {
        from { opacity: 0; transform: scale(0.9) translateY(-20px); }
        to { opacity: 1; transform: scale(1) translateY(0); }
    }
    
    .tutorial-header {
        padding: 24px 30px 20px;
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
    }
    
    .tutorial-header h2 {
        margin: 0;
        font-size: 1.5rem;
        font-weight: 700;
    }
    
    .tutorial-close {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
        font-size: 1.5rem;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s;
    }
    
    .tutorial-close:hover {
        background: rgba(255, 255, 255, 0.3);
    }
    
    .tutorial-body {
        padding: 30px;
        max-height: 60vh;
        overflow-y: auto;
    }
    
    .tutorial-progress {
        display: flex;
        align-items: center;
        gap: 15px;
        margin-bottom: 25px;
    }
    
    .progress-bar {
        flex: 1;
        height: 8px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        overflow: hidden;
    }
    
    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea, #764ba2);
        border-radius: 4px;
        transition: width 0.3s ease;
        width: 12.5%;
    }
    
    .progress-text {
        color: var(--muted);
        font-size: 0.9rem;
        white-space: nowrap;
    }
    
    .tutorial-step {
        color: var(--text);
        line-height: 1.6;
    }
    
    .tutorial-step h3 {
        color: #667eea;
        margin: 0 0 15px 0;
        font-size: 1.3rem;
    }
    
    .tutorial-step p {
        margin: 0 0 15px 0;
    }
    
    .tutorial-step .highlight-box {
        background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
        border: 1px solid rgba(102, 126, 234, 0.3);
        border-radius: 10px;
        padding: 20px;
        margin: 20px 0;
    }
    
    .tutorial-step .example-box {
        background: rgba(46, 204, 113, 0.1);
        border: 1px solid rgba(46, 204, 113, 0.3);
        border-radius: 10px;
        padding: 20px;
        margin: 20px 0;
    }
    
    .tutorial-step .warning-box {
        background: rgba(241, 196, 15, 0.1);
        border: 1px solid rgba(241, 196, 15, 0.3);
        border-radius: 10px;
        padding: 20px;
        margin: 20px 0;
    }
    
    .tutorial-footer {
        padding: 20px 30px;
        border-top: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(255, 255, 255, 0.02);
    }
    
    .tutorial-nav-center {
        display: flex;
        align-items: center;
    }
    
    .tutorial-dots {
        display: flex;
        gap: 8px;
    }
    
    .tutorial-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.3);
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .tutorial-dot.active {
        background: #667eea;
        transform: scale(1.2);
    }
    
    .tutorial-highlight {
        position: fixed;
        pointer-events: none;
        z-index: 9999;
        border: 3px solid #667eea;
        border-radius: 8px;
        box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
        transition: all 0.3s ease;
    }
    
    .tutorial-step img {
        max-width: 100%;
        border-radius: 8px;
        margin: 15px 0;
    }
    
    .tutorial-interactive-demo {
        background: var(--panel-2);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 20px;
        margin: 20px 0;
    }
    
    .tutorial-quiz {
        background: rgba(231, 76, 60, 0.1);
        border: 1px solid rgba(231, 76, 60, 0.3);
        border-radius: 10px;
        padding: 20px;
        margin: 20px 0;
    }
    
    .tutorial-quiz-option {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 12px 16px;
        margin: 8px 0;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .tutorial-quiz-option:hover {
        background: rgba(102, 126, 234, 0.1);
        border-color: #667eea;
    }
    
    .tutorial-quiz-option.correct {
        background: rgba(46, 204, 113, 0.2);
        border-color: #2ecc71;
    }
    
    .tutorial-quiz-option.incorrect {
        background: rgba(231, 76, 60, 0.2);
        border-color: #e74c3c;
    }
    </style>
</head>
<body>
    <div class="app">
        <header>
            <h1>Advanced Sampling Plan Analyzer</h1>
            <p>Developed by Chun-Chieh Chang (wesleychang2025@gmail.com). All Rights Reserved.</p>
        </header>
        <div class="main-layout">
            <aside class="sidebar">
                <nav class="tabs">
                    <div class="tab active" data-target="distribution">Probability Distribution</div>
                    <div class="tab" data-target="kaiyi">AQL Plan Table Lookup</div>
                    <div class="tab" data-target="reverse">Reverse Sampling Query</div>
                    <div class="tab" data-target="c0">C=0 Plan Table Lookup</div>
                    <div class="tab" data-target="aql-ltpd">AQL-LTPD Balanced Plan</div>
                    <div class="tab" data-target="plan">Multiple Plan Comparison</div>
                </nav>
            </aside>
            <div class="pages">

        <!-- Distribution Page -->
        <section id="section-distribution" class="section active">
            <div class="page-header">
                <h2>Probability Distribution</h2>
                <p>Compare Hypergeometric, Binomial, and Poisson distributions</p>
            </div>
            <div class="content">
                <aside class="left">
                    <div class="panel">
                        <h3>Theme</h3>
                        <div class="parameters">
                            <div class="group" style="grid-column: 1 / span 2;">
                                <label>Color Theme</label>
                                <select id="theme_selector" class="theme-selector" title="Select color theme">
                                    <option value="light">Light</option>
                                    <option value="light-blue">Light Blue</option>
                                    <option value="light-yellow">Light Yellow</option>
                                    <option value="light-pink">Light Pink</option>
                                    <option value="dark-teal">Dark Teal</option>
                                    <option value="dark-blue">Dark Blue</option>
                                    <option value="dark-gray">Dark Gray</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="panel">
                        <h3>Parameters</h3>
                        <div class="parameters">
                            <div class="group"><label>Lot Size (N)</label><input id="dist_lot_size" type="number" value="500" title="Lot Size (N)"></div>
                            <div class="group"><label>Sample Size (n)</label><input id="dist_n" type="number" value="124" title="Sample Size (n)"></div>
                            <div class="group" style="grid-column: 1 / span 2;"><label>Acceptance No. (c)</label><input id="dist_c" type="number" value="1" title="Acceptance No. (c)"></div>
                        </div>
                    </div>
                    <div class="panel">
                        <h3>Distribution Types</h3>
                        <div class="btn-row">
                            <button class="btn primary" data-dist="hyper" title="Hypergeometric Distribution">Hypergeo.</button>
                            <button class="btn" data-dist="binom" title="Binomial Distribution">Binomial</button>
                            <button class="btn" data-dist="pois" title="Poisson Distribution">Poisson</button>
                        </div>
                    </div>
                    
                    <div class="panel">
                        <h3>Learning</h3>
                        <button class="btn primary glass-button" id="start-tutorial-btn" style="width: 100%;">
                            🎓 Start Interactive Tutorial
                        </button>
                    </div>
                    
                </aside>
                <main class="right">
                    <div class="chart-card">
                        <div class="chart-toolbar">
                            <button class="btn" id="export_png">Export PNG</button>
                            <button class="btn" id="export_csv">Export Data</button>
                            <button class="btn" data-help-for="distribution" title="使用說明">Help</button>
                            <div style="margin-left:auto" class="btn-row">
                                <label style="color:var(--text); font-size:0.9em;">Defect Rate Max (%)</label>
                                <input id="x_max" type="number" value="5" title="Defect Rate Max (%)" style="width:80px; text-align:center; background:var(--panel); color:var(--text); border:1px solid var(--border); border-radius:6px; padding:6px 8px;">
                            </div>
                        </div>
                        <div class="chart">
                            <canvas id="ocChart"></canvas>
                        </div>
                    </div>
                </main>
            </div>
        </section>

        <!-- Empty shells for other pages (content to be ported) -->
        <section id="section-plan" class="section">
            <div class="page-header"><h2>Multiple Plan Comparison</h2><p>Compare OC curves from multiple sampling plans</p></div>
            <div class="content">
                <aside class="left">
                    <div class="panel">
                        <h3>Parameters</h3>
                        <div class="parameters">
                            <div class="group"><label>Sample Size (n)</label><input id="plan_n_input" type="number" value="125"></div>
                            <div class="group"><label>Acceptance No. (c)</label><input id="plan_c_input" type="number" value="1"></div>
                            <div class="group"><label>AQL (%)</label><input id="plan_aql_input" type="number" step="0.01" placeholder="optional"></div>
                            <div class="group"><label>Plan Label</label><input id="plan_label_input" type="text" placeholder="e.g., Plan A"></div>
                        </div>
                    </div>
                    <div class="panel">
                        <h3>Actions</h3>
                        <div class="btn-row">
                            <button class="btn primary" id="add-plan-btn">Add Plan</button>
                            <button class="btn" id="clear-all-btn">Clear All</button>
                        </div>
                        <div class="btn-row" style="margin-top: 8px;">
                            <button class="btn" id="show-oc-btn">Show OC Curves</button>
                            <button class="btn" id="show-aoq-btn">Show AOQ Curves</button>
                            <button class="btn" id="show-ati-btn">Show ATI Curves</button>
                        </div>
                    </div>
                    <div class="panel">
                        <h3>Sampling Plans</h3>
                        <ul id="plan-list" style="list-style:none; padding:0; margin:0; display:flex; flex-direction:column; gap:8px;"></ul>
                    </div>
                    <div class="panel">
                        <h3>⚠️ Distribution Types</h3>
                        <div style="font-size:0.85rem; color:var(--muted); line-height:1.4;">
                            <p><strong>Hypergeometric:</strong> Finite lot, no replacement (exact)</p>
                            <p><strong>Binomial:</strong> Infinite lot or with replacement</p>
                            <p><strong>Poisson:</strong> Approximation for large n, small p</p>
                            <p style="margin-top:8px; color:#f39c12;"><strong>Note:</strong> Plans from different pages may use different distributions, resulting in different OC curves even with same n,c values.</p>
                        </div>
                    </div>
                </aside>
                <main class="right">
                    <div class="chart-card">
                        <div class="chart-toolbar">
                            <button class="btn" id="plan_export_png">Export PNG</button>
                            <button class="btn" id="plan_export_csv">Export Data</button>
                            <button class="btn" id="plan_import_btn">Import from pages</button>
                            <button class="btn" data-help-for="plan" title="使用說明">Help</button>
                            <div style="margin-left:auto" class="btn-row">
                                <label style="color:var(--text); font-size:0.9em;">Defect Rate Max (%)</label>
                                <input id="plan_x_axis_max_input" type="number" value="5" style="width:80px; text-align:center; background:var(--panel); color:var(--text); border:1px solid var(--border); border-radius:6px; padding:6px 8px;">
                            </div>
                        </div>
                        <div class="chart">
                            <canvas id="ocChartPLAN"></canvas>
                        </div>
                    </div>
                </main>
            </div>
        </section>
        <section id="section-reverse" class="section">
            <div class="page-header"><h2>Reverse Sampling Query</h2><p>Fix three parameters to compute the remaining one</p></div>
            <div class="content">
                <aside class="left">
                    <div class="panel">
                        <h3>Parameters</h3>
                        <div class="parameters">
                            <div class="group" style="grid-column: 1 / span 2;"><label>Calculate Target</label>
                                <select id="rev_target_param">
                                    <option value="aql">Calculate AQL (%)</option>
                                    <option value="c">Calculate Acceptance No. (c)</option>
                                    <option value="n">Calculate Sample Size (n)</option>
                                    <option value="N">Calculate Lot Size (N)</option>
                                    <option value="targetPa">Calculate Target Pa (%)</option>
                                </select>
                            </div>
                            <div class="group"><label>Lot Size (N)</label><input id="rev_lot_size" type="number" value="500"></div>
                            <div class="group"><label>Sample Size (n)</label><input id="rev_n" type="number" value="125"></div>
                            <div class="group"><label>Acceptance No. (c)</label><input id="rev_c" type="number" value="1"></div>
                            <div class="group"><label>AQL (%)</label><input id="rev_aql" type="number" step="0.01" value="1.0"></div>
                            <div class="group" style="grid-column: 1 / span 2;"><label>Target Pa at AQL (%)</label><input id="rev_target_pa" type="number" step="0.1" value="95"></div>
                            <div class="group" style="grid-column: 1 / span 2;"><label>Distribution</label>
                                <select id="rev_dist_select">
                                    <option value="hyper">Hypergeometric</option>
                                    <option value="binom" selected>Binomial</option>
                                    <option value="pois">Poisson</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="panel">
                        <h3>Actions</h3>
                        <div class="btn-row">
                            <button class="btn primary" id="rev_calc_btn">Calculate Plan</button>
                            <button class="btn" id="rev_clear_btn">Clear</button>
                        </div>
                        <div id="rev_error" class="error-text"></div>
                        <div id="rev_info" class="info-text"></div>
                    </div>
                </aside>
                <main class="right">
                    <div class="chart-card">
                        <div class="chart-toolbar">
                            <button class="btn" id="rev_export_png">Export PNG</button>
                            <button class="btn" id="rev_export_csv">Export Data</button>
                            <button class="btn" id="rev_export_plan">Export to Plan Comparison</button>
                            <button class="btn" data-help-for="reverse" title="使用說明">Help</button>
                            <div style="margin-left:auto" class="btn-row">
                                <label style="color:var(--text); font-size:0.9em;">Defect Rate Max (%)</label>
                                <input id="rev_x_max" type="number" value="5" style="width:80px; text-align:center; background:var(--panel); color:var(--text); border:1px solid var(--border); border-radius:6px; padding:6px 8px;">
                            </div>
                        </div>
                        <div class="chart">
                            <canvas id="ocChartREV"></canvas>
                        </div>
                    </div>
                </main>
            </div>
        </section>
        <section id="section-kaiyi" class="section">
            <div class="page-header"><h2>AQL Plan Table Lookup</h2><p>Visualizing Sampling Standard (ANSI/ASQ Z1.4-2003)</p></div>
            <div class="content">
                <aside class="left">
                    <div class="panel">
                        <h3>Parameters</h3>
                        <div class="parameters">
                            <div class="group"><label>Lot Size (N)</label><input id="ss_lot_size" type="number" value="10000"></div>
                            <div class="group"><label>Inspection Level</label>
                                <select id="ss_inspection_level"></select>
                            </div>
                            <div class="group"><label>AQL</label>
                                <select id="ss_aql" data-default="0.4"></select>
                            </div>
                            <div class="group" style="grid-column: 1 / span 2;"><label>Custom AQL (%)</label><input id="ss_aql_custom" type="number" step="0.01" value="1.0" disabled></div>
                            <div class="group" style="grid-column: 1 / span 2;"><label>Inspection State</label>
                                <select id="ss_state_select">
                                    <option value="normal">Normal</option>
                                    <option value="tightened">Tightened</option>
                                    <option value="reduced" selected>Reduced</option>
                                </select>
                            </div>
                            <div class="group" style="grid-column: 1 / span 2;"><label>Distribution</label>
                                <select id="ss_dist_select">
                                    <option value="hyper">Hypergeometric</option>
                                    <option value="binom" selected>Binomial</option>
                                    <option value="pois">Poisson</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="panel">
                        <h3>Actions</h3>
                        <div class="btn-row">
                            <button class="btn primary" id="ss_lookup_btn">Lookup Plan</button>
                            <button class="btn" id="ss_clear_btn">Clear</button>
                        </div>
                        <div id="ss_error" class="error-text"></div>
                    </div>
                    <div class="panel">
                        <h3>Results</h3>
                        <div class="parameters" style="grid-template-columns: 1fr 1fr;">
                            <div class="group"><label>Code Letter</label><input id="ss_result_code" type="text" value="-" disabled></div>
                            <div class="group"><label>Sample Size (n)</label><input id="ss_result_n" type="text" value="-" disabled></div>
                            <div class="group"><label>Acceptance No. (Ac)</label><input id="ss_result_c" type="text" value="-" disabled></div>
                            <div class="group"><label>Rejection No. (Re)</label><input id="ss_result_re" type="text" value="-" disabled></div>
                            <div class="group"><label>Inspection</label><input id="ss_result_state" type="text" value="Normal" disabled></div>
                            <div class="group" style="grid-column: 1 / span 2;"><label>Notes</label><input id="ss_result_note" type="text" value="-" disabled></div>
                            <div class="group"><label>Pa (Accept at AQL)</label><input id="ss_result_pa" type="text" value="-" disabled></div>
                            <div class="group"><label>Pr (Reject at AQL)</label><input id="ss_result_prej" type="text" value="-" disabled></div>
                            <div class="group" style="grid-column: 1 / span 2;"><label>Pc (Continue at AQL)</label><input id="ss_result_pcont" type="text" value="-" disabled></div>
                        </div>
                    </div>
                </aside>
                <main class="right">
                    <div class="chart-card">
                        <div class="chart-toolbar">
                            <button class="btn" id="ss_export_png">Export PNG</button>
                            <button class="btn" id="ss_export_csv">Export Data</button>
                            <button class="btn" id="ss_export_plan">Export to Plan Comparison</button>
                            <button class="btn" data-help-for="kaiyi" title="使用說明">Help</button>
                            <div style="margin-left:auto" class="btn-row">
                                <label style="color:var(--text); font-size:0.9em;">Defect Rate Max (%)</label>
                                <input id="ss_x_max" type="number" value="5" style="width:80px; text-align:center; background:var(--panel); color:var(--text); border:1px solid var(--border); border-radius:6px; padding:6px 8px;">
                            </div>
                        </div>
                        <div class="chart">
                            <canvas id="ocChartAQL"></canvas>
                        </div>
                    </div>
                </main>
            </div>
        </section>
        <section id="section-c0" class="section">
            <div class="page-header"><h2>C=0 Plan Table Lookup</h2><p>Zero-acceptance sampling plan query (Nicholas L. Squeglia)</p></div>
            <div class="content">
                <aside class="left">
                    <div class="panel">
                        <h3>Parameters</h3>
                        <div class="parameters">
                            <div class="group"><label>Lot Size (N)</label><input id="c0_lot_size" type="number" value="500"></div>
                            <div class="group"><label>AQL</label>
                                <select id="c0_aql"></select>
                            </div>
                            <div class="group" style="grid-column: 1 / span 2;"><label>Custom AQL (%)</label><input id="c0_aql_custom" type="number" step="0.001" value="1.0" disabled></div>
                            <div class="group" style="grid-column: 1 / span 2;"><label>Distribution</label>
                                <select id="c0_dist_select">
                                    <option value="hyper">Hypergeometric</option>
                                    <option value="binom" selected>Binomial</option>
                                    <option value="pois">Poisson</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="panel">
                        <h3>Actions</h3>
                        <div class="btn-row">
                            <button class="btn primary" id="c0_lookup_btn">Lookup Plan</button>
                            <button class="btn" id="c0_clear_btn">Clear</button>
                        </div>
                        <div id="c0_error" class="error-text"></div>
                    </div>
                    <div class="panel">
                        <h3>Results</h3>
                        <div class="parameters" style="grid-template-columns: 1fr 1fr;">
                            <div class="group"><label>Sample Size (n)</label><input id="c0_result_n" type="text" value="-" disabled></div>
                            <div class="group"><label>Acceptance No. (c)</label><input id="c0_result_c" type="text" value="0" disabled></div>
                            <div class="group"><label>Used AQL</label><input id="c0_result_aql" type="text" value="-" disabled></div>
                            <div class="group"><label>Lot Range</label><input id="c0_result_lot_range" type="text" value="-" disabled></div>
                            <div class="group" style="grid-column: 1 / span 2;"><label>LTPD at Pa=10%</label><input id="c0_result_lq10" type="text" value="-" disabled></div>
                        </div>
                    </div>
                    
                </aside>
                <main class="right">
                    <div class="chart-card">
                        <div class="chart-toolbar">
                            <button class="btn" id="c0_export_png_toolbar">Export PNG</button>
                            <button class="btn" id="c0_export_csv_toolbar">Export Data</button>
                            <button class="btn" id="c0_export_plan">Export to Plan Comparison</button>
                            <button class="btn" data-help-for="c0" title="使用說明">Help</button>
                            <div style="margin-left:auto" class="btn-row">
                                <label style="color:var(--text); font-size:0.9em;">Defect Rate Max (%)</label>
                                <input id="c0_x_max" type="number" value="5" style="width:80px; text-align:center; background:var(--panel); color:var(--text); border:1px solid var(--border); border-radius:6px; padding:6px 8px;">
                            </div>
                        </div>
                        <div class="chart">
                            <canvas id="ocChartC0"></canvas>
                        </div>
                    </div>
                </main>
            </div>
        </section>
        
        <!-- AQL-LTPD Balanced Plan Page -->
        <section id="section-aql-ltpd" class="section">
            <div class="page-header">
                <h2>AQL-LTPD Balanced Sampling Plan</h2>
                <p>Design optimal sampling plans that balance both AQL and LTPD requirements using mathematical optimization models.</p>
            </div>
            <div class="content">
                <aside class="left">
                    <div class="panel">
                        <h3>Input Parameters</h3>
                        <div class="parameters">
                            <div class="group">
                                <label>AQL (%)</label>
                                <input id="aql_ltpd_aql_input" type="number" value="1.0" step="0.01" min="0.01" max="10.0">
                            </div>
                            <div class="group">
                                <label>LTPD (%)</label>
                                <input id="aql_ltpd_ltpd_input" type="number" value="5.0" step="0.1" min="0.1" max="50.0">
                            </div>
                            <div class="group">
                                <label>Lot Size (N)</label>
                                <input id="aql_ltpd_lot_size" type="number" value="1000" min="1">
                            </div>
                            <div class="group">
                                <label>Distribution</label>
                                <select id="aql_ltpd_dist_select">
                                    <option value="binom" selected>Binomial</option>
                                    <option value="pois">Poisson</option>
                                    <option value="hyper">Hypergeometric</option>
                                </select>
                            </div>
                            <div class="group">
                                <label>Optimization Target</label>
                                <select id="aql_ltpd_optimization">
                                    <option value="minimize_n" selected>Minimize Sample Size</option>
                                    <option value="balance">Balance AQL-LTPD</option>
                                    <option value="max_producer">Maximize Producer Protection</option>
                                    <option value="max_consumer">Maximize Consumer Protection</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="panel">
                        <h3>Risk Constraints</h3>
                        <div class="parameters">
                            <div class="group">
                                <label>Producer's Risk (α)</label>
                                <input id="aql_ltpd_alpha" type="number" value="0.05" step="0.01" min="0.01" max="0.20">
                            </div>
                            <div class="group">
                                <label>Consumer's Risk (β)</label>
                                <input id="aql_ltpd_beta" type="number" value="0.10" step="0.01" min="0.01" max="0.20">
                            </div>
                        </div>
                    </div>
                    
                    <div class="panel">
                        <h3>Actions</h3>
                        <div class="btn-row">
                            <button class="btn primary" id="aql_ltpd_calculate_btn">Calculate Plan</button>
                            <button class="btn" id="aql_ltpd_clear_btn">Clear</button>
                        </div>
                        <div id="aql_ltpd_error" class="error-text"></div>
                    </div>
                    
                    <div class="panel">
                        <h3>Recommended Plan</h3>
                        <div class="parameters" style="grid-template-columns: 1fr 1fr;">
                            <div class="group">
                                <label>Sample Size (n)</label>
                                <input id="aql_ltpd_result_n" type="text" value="-" disabled>
                            </div>
                            <div class="group">
                                <label>Acceptance No. (c)</label>
                                <input id="aql_ltpd_result_c" type="text" value="-" disabled>
                            </div>
                            <div class="group" style="grid-column: 1 / span 2;">
                                <label>Plan Efficiency (E = 1 - |Pa_AQL - (1-α)| - |Pa_LTPD - β| - penalty)</label>
                                <input id="aql_ltpd_efficiency" type="text" value="-" disabled>
                            </div>
                        </div>
                    </div>
                    
                    <div class="panel">
                        <h3>Performance Metrics</h3>
                        <div class="parameters">
                            <div class="group">
                                <label>Pa at AQL</label>
                                <input id="aql_ltpd_aql_pa" type="text" value="-" disabled>
                            </div>
                            <div class="group">
                                <label>Pa at LTPD</label>
                                <input id="aql_ltpd_ltpd_pa" type="text" value="-" disabled>
                            </div>
                            <div class="group">
                                <label>Actual α</label>
                                <input id="aql_ltpd_actual_alpha" type="text" value="-" disabled>
                            </div>
                            <div class="group">
                                <label>Actual β</label>
                                <input id="aql_ltpd_actual_beta" type="text" value="-" disabled>
                            </div>
                            <div class="group">
                                <label>AOQL (%)</label>
                                <input id="aql_ltpd_aoql" type="text" value="-" disabled>
                            </div>
                            <div class="group">
                                <label>ASN</label>
                                <input id="aql_ltpd_asn" type="text" value="-" disabled>
                            </div>
                        </div>
                    </div>
                    
                    <div class="panel">
                        <h3>Efficiency Rating & Recommendations</h3>
                        <div class="parameters" style="grid-template-columns: 1fr;">
                            <div class="group" style="grid-column: 1 / span 1;">
                                <label>Efficiency Rating</label>
                                <input id="aql_ltpd_efficiency_rating" type="text" value="-" disabled>
                            </div>
                            <div class="group" style="grid-column: 1 / span 1;">
                                <label>Improvement Suggestions</label>
                                <textarea id="aql_ltpd_improvements" rows="4" style="width: 100%; resize: vertical;" disabled></textarea>
                            </div>
                        </div>
                    </div>
                    
                    <div class="panel">
                        <h3>Notes</h3>
                        <div id="aql_ltpd_notes" class="notes-text">Enter AQL and LTPD values to calculate the optimal sampling plan.</div>
                    </div>
                </aside>
                
                <main class="right">
                    <div class="chart-card">
                        <div class="chart-toolbar">
                            <button class="btn" id="aql_ltpd_export_png_toolbar">Export PNG</button>
                            <button class="btn" id="aql_ltpd_export_csv_toolbar">Export Data</button>
                            <button class="btn" id="aql_ltpd_export_plan">Export to Plan Comparison</button>
                            <button class="btn" data-help-for="aql-ltpd" title="使用說明">Help</button>
                            <div style="margin-left:auto" class="btn-row">
                                <label style="color:var(--text); font-size:0.9em;">Defect Rate Max (%)</label>
                                <input id="aql_ltpd_x_max" type="number" value="10" style="width:80px; text-align:center; background:var(--panel); color:var(--text); border:1px solid var(--border); border-radius:6px; padding:6px 8px;">
                            </div>
                        </div>
                        <div class="chart">
                            <canvas id="ocChartAQL_LTPD"></canvas>
                        </div>
                    </div>
                </main>
            </div>
        </section>
            </div>
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div id="tutorial-modal" class="tutorial-modal" style="display: none;">
        <div class="tutorial-overlay"></div>
        <div class="tutorial-content">
            <div class="tutorial-header">
                <h2 id="tutorial-title">🎓 Interactive Sampling Plan Tutorial</h2>
                <button class="tutorial-close" id="tutorial-close-btn">×</button>
            </div>
            <div class="tutorial-body">
                <div class="tutorial-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" id="tutorial-progress-fill"></div>
                    </div>
                    <span class="progress-text" id="tutorial-progress-text">Step 1 of 8</span>
                </div>
                <div class="tutorial-step" id="tutorial-step-content">
                    <!-- Dynamic content will be inserted here -->
                </div>
            </div>
            <div class="tutorial-footer">
                <button class="btn" id="tutorial-prev-btn" style="display: none;">← Previous</button>
                <div class="tutorial-nav-center">
                    <div class="tutorial-dots" id="tutorial-dots"></div>
                </div>
                <button class="btn primary" id="tutorial-next-btn">Next →</button>
            </div>
        </div>
    </div>

    <!-- Tutorial Highlight Overlay -->
    <div id="tutorial-highlight" class="tutorial-highlight" style="display: none;"></div>

    <!-- Scripts: Only layout wiring now; functional logic to be ported stepwise -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script>
    <script>
    // ===== Theme Management =====
    function initThemeSystem() {
        const themeSelector = document.getElementById('theme_selector');
        const body = document.body;
        
        // Load saved theme or default to dark-teal
        const savedTheme = localStorage.getItem('app-theme') || 'dark-teal';
        themeSelector.value = savedTheme;
        applyTheme(savedTheme);
        
        // Theme change handler
        themeSelector.addEventListener('change', function() {
            const selectedTheme = this.value;
            applyTheme(selectedTheme);
            localStorage.setItem('app-theme', selectedTheme);
        });
    }
    
    function applyTheme(theme) {
        const body = document.body;
        
        // Remove existing theme attributes
        body.removeAttribute('data-theme');
        
        // Apply new theme (dark-teal is default, no attribute needed)
        if (theme !== 'dark-teal') {
            body.setAttribute('data-theme', theme);
        }
        
        // Add smooth transition class temporarily
        body.style.transition = 'all 0.3s ease';
        setTimeout(() => {
            body.style.transition = '';
        }, 300);
        
        // Update charts if they exist
        updateChartColors();
    }
    
    function getThemeColors() {
        const theme = document.body.getAttribute('data-theme') || 'dark-teal';
        const isLightTheme = ['light', 'light-blue', 'light-yellow', 'light-pink'].includes(theme);
        
        return {
            text: isLightTheme ? '#212529' : '#c7cacf',
            grid: isLightTheme ? 'rgba(0,0,0,0.1)' : 'rgba(199,202,207,0.22)'
        };
    }
    
    // Enhanced theme color function with better contrast
    function getEnhancedThemeColors() {
        const theme = document.body.getAttribute('data-theme') || 'dark-teal';
        const isLightTheme = ['light', 'light-blue', 'light-yellow', 'light-pink'].includes(theme);
        
        // Enhanced colors with better contrast for visibility
        if (isLightTheme) {
            return {
                text: '#212529', // Dark text for better contrast
                grid: 'rgba(0,0,0,0.5)', // Darker grid for visibility
                background: getCssVar('--panel-2') || getCssVar('--panel') || '#ffffff'
            };
        } else {
            return {
                text: '#e6e9ee', // Light text for dark themes
                grid: 'rgba(199,202,207,0.4)', // More visible grid lines
                background: getCssVar('--panel-2') || getCssVar('--panel') || '#111c26'
            };
        }
    }
    
    function updateChartColors() {
        const colors = getEnhancedThemeColors();
        
        // Update existing charts
        [ocChart, planChart, revChart, ssChart, c0Chart, aqlLtpdChart].forEach(chart => {
            if (chart && chart.options) {
                // Update legend color
                if (chart.options.plugins && chart.options.plugins.legend && chart.options.plugins.legend.labels) {
                    chart.options.plugins.legend.labels.color = colors.text;
                }
                // Update title color if present
                if (chart.options.plugins && chart.options.plugins.title) {
                    chart.options.plugins.title.color = colors.text;
                }
                
                // Update grid, axis title, tick label, and axis border colors
                if (chart.options.scales) {
                    if (chart.options.scales.x) {
                        if (chart.options.scales.x.grid) {
                            chart.options.scales.x.grid.color = colors.grid;
                        }
                        if (chart.options.scales.x.title) {
                            chart.options.scales.x.title.color = colors.text;
                        }
                        if (chart.options.scales.x.ticks) {
                            chart.options.scales.x.ticks.color = colors.text;
                        }
                        if (chart.options.scales.x.border) {
                            chart.options.scales.x.border.color = colors.grid;
                        }
                    }
                    if (chart.options.scales.y) {
                        if (chart.options.scales.y.grid) {
                            chart.options.scales.y.grid.color = colors.grid;
                        }
                        if (chart.options.scales.y.title) {
                            chart.options.scales.y.title.color = colors.text;
                        }
                        if (chart.options.scales.y.ticks) {
                            chart.options.scales.y.ticks.color = colors.text;
                        }
                        if (chart.options.scales.y.border) {
                            chart.options.scales.y.border.color = colors.grid;
                        }
                    }
                }
                
                chart.update();
            }
        });
    }
    
    // ===== Embedded Master Tables Data =====
    
    // C=0 Sampling Plan Data Table
    const C0_SAMPLING_TABLE = [
        {'lot_range': [2, 8], 'samples': {'0.010': null, '0.015': null, '0.025': null, '0.040': null, '0.065': null, '0.10': null, '0.15': null, '0.25': null, '0.40': null, '0.65': null, '1.0': null, '1.5': null, '2.5': 5, '4.0': 3, '6.5': 2, '10.0': 2}},
        {'lot_range': [9, 15], 'samples': {'0.010': null, '0.015': null, '0.025': null, '0.040': null, '0.065': null, '0.10': null, '0.15': null, '0.25': null, '0.40': null, '0.65': null, '1.0': 13, '1.5': 8, '2.5': 5, '4.0': 3, '6.5': 2, '10.0': 2}},
        {'lot_range': [16, 25], 'samples': {'0.010': null, '0.015': null, '0.025': null, '0.040': null, '0.065': null, '0.10': null, '0.15': null, '0.25': null, '0.40': null, '0.65': 20, '1.0': 13, '1.5': 8, '2.5': 5, '4.0': 3, '6.5': 3, '10.0': 2}},
        {'lot_range': [26, 50], 'samples': {'0.010': null, '0.015': null, '0.025': null, '0.040': null, '0.065': null, '0.10': null, '0.15': null, '0.25': null, '0.40': 32, '0.65': 20, '1.0': 13, '1.5': 8, '2.5': 5, '4.0': 5, '6.5': 5, '10.0': 3}},
        {'lot_range': [51, 90], 'samples': {'0.010': null, '0.015': null, '0.025': null, '0.040': null, '0.065': null, '0.10': null, '0.15': 80, '0.25': 50, '0.40': 32, '0.65': 20, '1.0': 13, '1.5': 8, '2.5': 7, '4.0': 6, '6.5': 5, '10.0': 4}},
        {'lot_range': [91, 150], 'samples': {'0.010': null, '0.015': null, '0.025': null, '0.040': null, '0.065': null, '0.10': 125, '0.15': 80, '0.25': 50, '0.40': 32, '0.65': 20, '1.0': 13, '1.5': 12, '2.5': 11, '4.0': 7, '6.5': 6, '10.0': 5}},
        {'lot_range': [151, 280], 'samples': {'0.010': null, '0.015': null, '0.025': null, '0.040': 200, '0.065': 125, '0.10': 80, '0.15': 50, '0.25': 32, '0.40': 20, '0.65': 20, '1.0': 19, '1.5': 13, '2.5': 13, '4.0': 10, '6.5': 7, '10.0': 6}},
        {'lot_range': [281, 500], 'samples': {'0.010': null, '0.015': null, '0.025': null, '0.040': 315, '0.065': 200, '0.10': 125, '0.15': 80, '0.25': 50, '0.40': 48, '0.65': 47, '1.0': 29, '1.5': 21, '2.5': 16, '4.0': 11, '6.5': 9, '10.0': 7}},
        {'lot_range': [501, 1200], 'samples': {'0.010': null, '0.015': 800, '0.025': 500, '0.040': 315, '0.065': 200, '0.10': 125, '0.15': 80, '0.25': 75, '0.40': 73, '0.65': 47, '1.0': 34, '1.5': 27, '2.5': 19, '4.0': 15, '6.5': 11, '10.0': 8}},
        {'lot_range': [1201, 3200], 'samples': {'0.010': 1250, '0.015': 800, '0.025': 500, '0.040': 315, '0.065': 200, '0.10': 125, '0.15': 120, '0.25': 116, '0.40': 73, '0.65': 53, '1.0': 42, '1.5': 35, '2.5': 23, '4.0': 18, '6.5': 13, '10.0': 9}},
        {'lot_range': [3201, 10000], 'samples': {'0.010': 1250, '0.015': 800, '0.025': 500, '0.040': 315, '0.065': 200, '0.10': 192, '0.15': 189, '0.25': 116, '0.40': 86, '0.65': 68, '1.0': 50, '1.5': 38, '2.5': 29, '4.0': 22, '6.5': 15, '10.0': 9}},
        {'lot_range': [10001, 35000], 'samples': {'0.010': 1250, '0.015': 800, '0.025': 500, '0.040': 315, '0.065': 300, '0.10': 294, '0.15': 189, '0.25': 135, '0.40': 108, '0.65': 77, '1.0': 60, '1.5': 46, '2.5': 35, '4.0': 29, '6.5': 15, '10.0': 9}},
        {'lot_range': [35001, 150000], 'samples': {'0.010': 1250, '0.015': 800, '0.025': 500, '0.040': 490, '0.065': 476, '0.10': 294, '0.15': 218, '0.25': 170, '0.40': 123, '0.65': 96, '1.0': 74, '1.5': 56, '2.5': 40, '4.0': 29, '6.5': 15, '10.0': 9}},
        {'lot_range': [150001, 500000], 'samples': {'0.010': 1250, '0.015': 800, '0.025': 750, '0.040': 715, '0.065': 476, '0.10': 345, '0.15': 270, '0.25': 200, '0.40': 156, '0.65': 119, '1.0': 90, '1.5': 64, '2.5': 40, '4.0': 29, '6.5': 15, '10.0': 9}},
        {'lot_range': [500001, Infinity], 'samples': {'0.010': 1250, '0.015': 1200, '0.025': 1112, '0.040': 715, '0.065': 556, '0.10': 435, '0.15': 303, '0.25': 244, '0.40': 189, '0.65': 143, '1.0': 102, '1.5': 64, '2.5': 40, '4.0': 29, '6.5': 15, '10.0': 9}},
    ];

    // Code Letter Table
    const codeLetterTable = [
        { min: 2, max: 8,     levels: { 'I': 'A', 'II': 'A', 'III': 'B', 'S-1': 'A', 'S-2': 'A', 'S-3': 'A', 'S-4': 'A' } },
        { min: 9, max: 15,    levels: { 'I': 'A', 'II': 'B', 'III': 'C', 'S-1': 'A', 'S-2': 'A', 'S-3': 'A', 'S-4': 'A' } },
        { min: 16, max: 25,   levels: { 'I': 'B', 'II': 'C', 'III': 'D', 'S-1': 'A', 'S-2': 'A', 'S-3': 'B', 'S-4': 'B' } },
        { min: 26, max: 50,   levels: { 'I': 'C', 'II': 'D', 'III': 'E', 'S-1': 'A', 'S-2': 'B', 'S-3': 'B', 'S-4': 'C' } },
        { min: 51, max: 90,   levels: { 'I': 'C', 'II': 'E', 'III': 'F', 'S-1': 'B', 'S-2': 'B', 'S-3': 'C', 'S-4': 'C' } },
        { min: 91, max: 150,  levels: { 'I': 'D', 'II': 'F', 'III': 'G', 'S-1': 'B', 'S-2': 'B', 'S-3': 'C', 'S-4': 'D' } },
        { min: 151, max: 280, levels: { 'I': 'E', 'II': 'G', 'III': 'H', 'S-1': 'B', 'S-2': 'C', 'S-3': 'D', 'S-4': 'E' } },
        { min: 281, max: 500, levels: { 'I': 'F', 'II': 'H', 'III': 'J', 'S-1': 'B', 'S-2': 'C', 'S-3': 'D', 'S-4': 'E' } },
        { min: 501, max: 1200, levels: { 'I': 'G', 'II': 'J', 'III': 'K', 'S-1': 'C', 'S-2': 'C', 'S-3': 'E', 'S-4': 'F' } },
        { min: 1201, max: 3200, levels: { 'I': 'H', 'II': 'K', 'III': 'L', 'S-1': 'C', 'S-2': 'D', 'S-3': 'E', 'S-4': 'G' } },
        { min: 3201, max: 10000, levels: { 'I': 'J', 'II': 'L', 'III': 'M', 'S-1': 'C', 'S-2': 'D', 'S-3': 'F', 'S-4': 'G' } },
        { min: 10001, max: 35000, levels: { 'I': 'K', 'II': 'M', 'III': 'N', 'S-1': 'C', 'S-2': 'D', 'S-3': 'F', 'S-4': 'H' } },
        { min: 35001, max: 150000, levels: { 'I': 'L', 'II': 'N', 'III': 'P', 'S-1': 'D', 'S-2': 'E', 'S-3': 'G', 'S-4': 'J' } },
        { min: 150001, max: 500000, levels: { 'I': 'M', 'II': 'P', 'III': 'Q', 'S-1': 'D', 'S-2': 'E', 'S-3': 'G', 'S-4': 'J' } },
        { min: 500001, max: null, levels: { 'I': 'N', 'II': 'Q', 'III': 'R', 'S-1': 'D', 'S-2': 'E', 'S-3': 'H', 'S-4': 'K' } }
    ];

    // Normal Inspection Database
    const codeLettersOrder_normal = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R'];
    const normal_sampleSizes = {'A': 2, 'B': 3, 'C': 5, 'D': 8, 'E': 13, 'F': 20, 'G': 32, 'H': 50, 'J': 80, 'K': 125, 'L': 200, 'M': 315, 'N': 500, 'P': 800, 'Q': 1250, 'R': 2000};
    const normal_rawMasterTableData = {
        'A': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': 'down', '1.0': 'down', '1.5': 'down', '2.5': 'down', '4.0': 'down', '6.5': 0     , '10': 'down', '15': 'down', '25': 1     , '40': 2     , '65': 3     , '100': 5     , '150': 7     , '250': 10    , '400': 14    , '650': 21    , '1000': 30    },
        'B': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': 'down', '1.0': 'down', '1.5': 'down', '2.5': 'down', '4.0': 0     , '6.5': 'up'  , '10': 'down', '15': 1     , '25': 2     , '40': 3     , '65': 5     , '100': 7     , '150': 10    , '250': 14    , '400': 21    , '650': 30    , '1000': 44    },
        'C': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': 'down', '1.0': 'down', '1.5': 'down', '2.5': 0     , '4.0': 'up'  , '6.5': 'down', '10': 1     , '15': 2     , '25': 3     , '40': 5     , '65': 7     , '100': 10    , '150': 14    , '250': 21    , '400': 30    , '650': 44    , '1000': 'up'  },
        'D': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': 'down', '1.0': 'down', '1.5': 0     , '2.5': 'up'  , '4.0': 'down', '6.5': 1     , '10': 2     , '15': 3     , '25': 5     , '40': 7     , '65': 10    , '100': 14    , '150': 21    , '250': 30    , '400': 44    , '650': 'up'  , '1000': 'up'  },
        'E': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': 'down', '1.0': 0     , '1.5': 'up'  , '2.5': 'down', '4.0': 1     , '6.5': 2     , '10': 3     , '15': 5     , '25': 7     , '40': 10    , '65': 14    , '100': 21    , '150': 30    , '250': 44    , '400': 'up'  , '650': 'up'  , '1000': 'up'  },
        'F': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': 0     , '1.0': 'up'  , '1.5': 'down', '2.5': 1     , '4.0': 2     , '6.5': 3     , '10': 5     , '15': 7     , '25': 10    , '40': 14    , '65': 21    , '100': 'up'  , '150': 'up'  , '250': 'up'  , '400': 'up'  , '650': 'up'  , '1000': 'up'  },
        'G': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 0     , '0.65': 'up'  , '1.0': 'down', '1.5': 1     , '2.5': 2     , '4.0': 3     , '6.5': 5     , '10': 7     , '15': 10    , '25': 14    , '40': 21    , '65': 'up'  , '100': 'up'  , '150': 'up'  , '250': 'up'  , '400': 'up'  , '650': 'up'  , '1000': 'up'  },
        'H': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 0     , '0.40': 'up'  , '0.65': 'down', '1.0': 1     , '1.5': 2     , '2.5': 3     , '4.0': 5     , '6.5': 7     , '10': 10    , '15': 14    , '25': 21    , '40': 'up'  , '65': 'up'  , '100': 'up'  , '150': 'up'  , '250': 'up'  , '400': 'up'  , '650': 'up'  , '1000': 'up'  },
        'J': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 0     , '0.25': 'up'  , '0.40': 'down', '0.65': 1     , '1.0': 2     , '1.5': 3     , '2.5': 5     , '4.0': 7     , '6.5': 10    , '10': 14    , '15': 21    , '25': 'up'  , '40': 'up'  , '65': 'up'  , '100': 'up'  , '150': 'up'  , '250': 'up'  , '400': 'up'  , '650': 'up'  , '1000': 'up'  },
        'K': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 0     , '0.15': 'up'  , '0.25': 'down', '0.40': 1     , '0.65': 2     , '1.0': 3     , '1.5': 5     , '2.5': 7     , '4.0': 10    , '6.5': 14    , '10': 21    , '15': 'up'  , '25': 'up'  , '40': 'up'  , '65': 'up'  , '100': 'up'  , '150': 'up'  , '250': 'up'  , '400': 'up'  , '650': 'up'  , '1000': 'up'  },
        'L': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 0     , '0.10': 'up'  , '0.15': 'down', '0.25': 1     , '0.40': 2     , '0.65': 3     , '1.0': 5     , '1.5': 7     , '2.5': 10    , '4.0': 14    , '6.5': 21    , '10': 'up'  , '15': 'up'  , '25': 'up'  , '40': 'up'  , '65': 'up'  , '100': 'up'  , '150': 'up'  , '250': 'up'  , '400': 'up'  , '650': 'up'  , '1000': 'up'  },
        'M': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 0     , '0.065': 'up'  , '0.10': 'down', '0.15': 1     , '0.25': 2     , '0.40': 3     , '0.65': 5     , '1.0': 7     , '1.5': 10    , '2.5': 14    , '4.0': 21    , '6.5': 'up'  , '10': 'up'  , '15': 'up'  , '25': 'up'  , '40': 'up'  , '65': 'up'  , '100': 'up'  , '150': 'up'  , '250': 'up'  , '400': 'up'  , '650': 'up'  , '1000': 'up'  },
        'N': { '0.010': 'down', '0.015': 'down', '0.025': 0     , '0.040': 'up'  , '0.065': 'down', '0.10': 1     , '0.15': 2     , '0.25': 3     , '0.40': 5     , '0.65': 7     , '1.0': 10    , '1.5': 14    , '2.5': 21    , '4.0': 'up'  , '6.5': 'up'  , '10': 'up'  , '15': 'up'  , '25': 'up'  , '40': 'up'  , '65': 'up'  , '100': 'up'  , '150': 'up'  , '250': 'up'  , '400': 'up'  , '650': 'up'  , '1000': 'up'  },
        'P': { '0.010': 'down', '0.015': 0     , '0.025': 'up'  , '0.040': 'down', '0.065': 1     , '0.10': 2     , '0.15': 3     , '0.25': 5     , '0.40': 7     , '0.65': 10    , '1.0': 14    , '1.5': 21    , '2.5': 'up'  , '4.0': 'up'  , '6.5': 'up'  , '10': 'up'  , '15': 'up'  , '25': 'up'  , '40': 'up'  , '65': 'up'  , '100': 'up'  , '150': 'up'  , '250': 'up'  , '400': 'up'  , '650': 'up'  , '1000': 'up'  },
        'Q': { '0.010': 0     , '0.015': 'up'  , '0.025': 'down', '0.040': 1     , '0.065': 2     , '0.10': 3     , '0.15': 5     , '0.25': 7     , '0.40': 10    , '0.65': 14    , '1.0': 21    , '1.5': 'up'  , '2.5': 'up'  , '4.0': 'up'  , '6.5': 'up'  , '10': 'up'  , '15': 'up'  , '25': 'up'  , '40': 'up'  , '65': 'up'  , '100': 'up'  , '150': 'up'  , '250': 'up'  , '400': 'up'  , '650': 'up'  , '1000': 'up'  },
        'R': { '0.010': 'up'  , '0.015': 'up'  , '0.025': 1     , '0.040': 2     , '0.065': 3     , '0.10': 5     , '0.15': 7     , '0.25': 10    , '0.40': 14    , '0.65': 21    , '1.0': 'up'  , '1.5': 'up'  , '2.5': 'up'  , '4.0': 'up'  , '6.5': 'up'  , '10': 'up'  , '15': 'up'  , '25': 'up'  , '40': 'up'  , '65': 'up'  , '100': 'up'  , '150': 'up'  , '250': 'up'  , '400': 'up'  , '650': 'up'  , '1000': 'up'  }
    };

    // Reduced Inspection Database (embedded for standalone use)
    const codeLettersOrder_reduced = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R'];
    const reduced_sampleSizes = {'A': 2, 'B': 2, 'C': 2, 'D': 3, 'E': 5, 'F': 8, 'G': 13, 'H': 20, 'J': 32, 'K': 50, 'L': 80, 'M': 125, 'N': 200, 'P': 315, 'Q': 500, 'R': 800};
    const reduced_rawMasterTableData = {
        'A': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': 'down' , '1.0': 'down' , '1.5': 'down' , '2.5': 'down' , '4.0': 'down' , '6.5': { ac: 0, re: 1 } , '10': 'down' , '15': 'down' , '25': { ac: 1, re: 2 } , '40': { ac: 2, re: 3 } , '65': { ac: 3, re: 4 } , '100': { ac: 5, re: 6 } , '150': { ac: 7, re: 8 } , '250': { ac: 10, re: 11 } , '400': { ac: 14, re: 15 } , '650': { ac: 21, re: 22 } , '1000': { ac: 30, re: 31 } },
        'B': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': 'down' , '1.0': 'down' , '1.5': 'down' , '2.5': 'down' , '4.0': { ac: 0, re: 1 } , '6.5': 'up'   , '10': 'down' , '15': { ac: 0, re: 2 } , '25': { ac: 1, re: 3 } , '40': { ac: 2, re: 4 } , '65': { ac: 3, re: 5 } , '100': { ac: 5, re: 6 } , '150': { ac: 7, re: 8 } , '250': { ac: 10, re: 11 } , '400': { ac: 14, re: 15 } , '650': { ac: 21, re: 22 } , '1000': { ac: 30, re: 31 } },
        'C': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': 'down' , '1.0': 'down' , '1.5': 'down' , '2.5': { ac: 0, re: 1 } , '4.0': 'up'   , '6.5': 'down' , '10': { ac: 0, re: 2 } , '15': { ac: 1, re: 3 } , '25': { ac: 1, re: 4 } , '40': { ac: 2, re: 5 } , '65': { ac: 3, re: 6 } , '100': { ac: 5, re: 8 } , '150': { ac: 7, re: 10 } , '250': { ac: 10, re: 13 } , '400': { ac: 14, re: 17 } , '650': { ac: 21, re: 24 } , '1000': 'up'   },
        'D': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': 'down' , '1.0': 'down' , '1.5': { ac: 0, re: 1 } , '2.5': 'up'   , '4.0': 'down' , '6.5': { ac: 0, re: 2 } , '10': { ac: 1, re: 3 } , '15': { ac: 1, re: 4 } , '25': { ac: 2, re: 5 } , '40': { ac: 3, re: 6 } , '65': { ac: 5, re: 8 } , '100': { ac: 7, re: 10 } , '150': { ac: 10, re: 13 } , '250': { ac: 14, re: 17 } , '400': { ac: 21, re: 24 } , '650': 'up'   , '1000': 'up'   },
        'E': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': 'down' , '1.0': { ac: 0, re: 1 } , '1.5': 'up'   , '2.5': 'down' , '4.0': { ac: 0, re: 2 } , '6.5': { ac: 1, re: 3 } , '10': { ac: 1, re: 4 } , '15': { ac: 2, re: 5 } , '25': { ac: 3, re: 6 } , '40': { ac: 5, re: 8 } , '65': { ac: 7, re: 10 } , '100': { ac: 10, re: 13 } , '150': { ac: 14, re: 17 } , '250': { ac: 21, re: 24 } , '400': 'up'   , '650': 'up'   , '1000': 'up'   },
        'F': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': { ac: 0, re: 1 } , '1.0': 'up'   , '1.5': 'down' , '2.5': { ac: 0, re: 2 } , '4.0': { ac: 1, re: 3 } , '6.5': { ac: 1, re: 4 } , '10': { ac: 2, re: 5 } , '15': { ac: 3, re: 6 } , '25': { ac: 5, re: 8 } , '40': { ac: 7, re: 10 } , '65': { ac: 10, re: 13 } , '100': 'up'   , '150': 'up'   , '250': 'up'   , '400': 'up'   , '650': 'up'   , '1000': 'up'   },
        'G': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': { ac: 0, re: 1 } , '0.65': 'up'   , '1.0': 'down' , '1.5': { ac: 0, re: 2 } , '2.5': { ac: 1, re: 3 } , '4.0': { ac: 1, re: 4 } , '6.5': { ac: 2, re: 5 } , '10': { ac: 3, re: 6 } , '15': { ac: 5, re: 8 } , '25': { ac: 7, re: 10 } , '40': { ac: 10, re: 13 } , '65': 'up'   , '100': 'up'   , '150': 'up'   , '250': 'up'   , '400': 'up'   , '650': 'up'   , '1000': 'up'   },
        'H': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': { ac: 0, re: 1 } , '0.40': 'up'  , '0.65': 'down' , '1.0': { ac: 0, re: 2 } , '1.5': { ac: 1, re: 3 } , '2.5': { ac: 1, re: 4 } , '4.0': { ac: 2, re: 5 } , '6.5': { ac: 3, re: 6 } , '10': { ac: 5, re: 8 } , '15': { ac: 7, re: 10 } , '25': { ac: 10, re: 13 } , '40': 'up'   , '65': 'up'   , '100': 'up'   , '150': 'up'   , '250': 'up'   , '400': 'up'   , '650': 'up'   , '1000': 'up'   },
        'J': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': { ac: 0, re: 1 } , '0.25': 'up'  , '0.40': 'down', '0.65': { ac: 0, re: 2 } , '1.0': { ac: 1, re: 3 } , '1.5': { ac: 1, re: 4 } , '2.5': { ac: 2, re: 5 } , '4.0': { ac: 3, re: 6 } , '6.5': { ac: 5, re: 8 } , '10': { ac: 7, re: 10 } , '15': { ac: 10, re: 13 } , '25': 'up'   , '40': 'up'   , '65': 'up'   , '100': 'up'   , '150': 'up'   , '250': 'up'   , '400': 'up'   , '650': 'up'   , '1000': 'up'   },
        'K': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': { ac: 0, re: 1 } , '0.15': 'up'  , '0.25': 'down', '0.40': { ac: 0, re: 2 } , '0.65': { ac: 1, re: 3 } , '1.0': { ac: 1, re: 4 } , '1.5': { ac: 2, re: 5 } , '2.5': { ac: 3, re: 6 } , '4.0': { ac: 5, re: 8 } , '6.5': { ac: 7, re: 10 } , '10': { ac: 10, re: 13 } , '15': 'up'   , '25': 'up'   , '40': 'up'   , '65': 'up'   , '100': 'up'   , '150': 'up'   , '250': 'up'   , '400': 'up'   , '650': 'up'   , '1000': 'up'   },
        'L': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': { ac: 0, re: 1 } , '0.10': 'up'  , '0.15': 'down', '0.25': { ac: 0, re: 2 } , '0.40': { ac: 1, re: 3 } , '0.65': { ac: 1, re: 4 } , '1.0': { ac: 2, re: 5 } , '1.5': { ac: 3, re: 6 } , '2.5': { ac: 5, re: 8 } , '4.0': { ac: 7, re: 10 } , '6.5': { ac: 10, re: 14 } , '10': 'up'   , '15': 'up'   , '25': 'up'   , '40': 'up'   , '65': 'up'   , '100': 'up'   , '150': 'up'   , '250': 'up'   , '400': 'up'   , '650': 'up'   , '1000': 'up'   },
        'M': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': { ac: 0, re: 1 } , '0.065': 'up'  , '0.10': 'down', '0.15': { ac: 0, re: 2 } , '0.25': { ac: 1, re: 3 } , '0.40': { ac: 1, re: 4 } , '0.65': { ac: 2, re: 5 } , '1.0': { ac: 3, re: 6 } , '1.5': { ac: 5, re: 8 } , '2.5': { ac: 7, re: 10 } , '4.0': { ac: 10, re: 13 } , '6.5': 'up'   , '10': 'up'   , '15': 'up'   , '25': 'up'   , '40': 'up'   , '65': 'up'   , '100': 'up'   , '150': 'up'   , '250': 'up'   , '400': 'up'   , '650': 'up'   , '1000': 'up'   },
        'N': { '0.010': 'down', '0.015': 'down', '0.025': { ac: 0, re: 1 } , '0.040': 'up'  , '0.065': 'down', '0.10': { ac: 0, re: 2 } , '0.15': { ac: 1, re: 3 } , '0.25': { ac: 1, re: 4 } , '0.40': { ac: 2, re: 5 } , '0.65': { ac: 3, re: 6 } , '1.0': { ac: 5, re: 8 } , '1.5': { ac: 7, re: 10 } , '2.5': { ac: 10, re: 13 } , '4.0': 'up'   , '6.5': 'up'   , '10': 'up'   , '15': 'up'   , '25': 'up'   , '40': 'up'   , '65': 'up'   , '100': 'up'   , '150': 'up'   , '250': 'up'   , '400': 'up'   , '650': 'up'   , '1000': 'up'   },
        'P': { '0.010': 'down', '0.015': { ac: 0, re: 1 } , '0.025': 'up'  , '0.040': 'down', '0.065': { ac: 0, re: 2 } , '0.10': { ac: 1, re: 3 } , '0.15': { ac: 1, re: 4 } , '0.25': { ac: 2, re: 5 } , '0.40': { ac: 3, re: 6 } , '0.65': { ac: 5, re: 8 } , '1.0': { ac: 7, re: 10 } , '1.5': { ac: 10, re: 13 } , '2.5': 'up'   , '4.0': 'up'   , '6.5': 'up'   , '10': 'up'   , '15': 'up'   , '25': 'up'   , '40': 'up'   , '65': 'up'   , '100': 'up'   , '150': 'up'   , '250': 'up'   , '400': 'up'   , '650': 'up'   , '1000': 'up'   },
        'Q': { '0.010': { ac: 0, re: 1 } , '0.015': 'up'  , '0.025': 'down', '0.040': { ac: 0, re: 2 } , '0.065': { ac: 1, re: 3 } , '0.10': { ac: 1, re: 4 } , '0.15': { ac: 2, re: 5 } , '0.25': { ac: 3, re: 6 } , '0.40': { ac: 5, re: 8 } , '0.65': { ac: 7, re: 10 } , '1.0': { ac: 10, re: 13 } , '1.5': 'up'   , '2.5': 'up'   , '4.0': 'up'   , '6.5': 'up'   , '10': 'up'   , '15': 'up'   , '25': 'up'   , '40': 'up'   , '65': 'up'   , '100': 'up'   , '150': 'up'   , '250': 'up'   , '400': 'up'   , '650': 'up'   , '1000': 'up'   },
        'R': { '0.010': 'up'  , '0.015': 'up'  , '0.025': { ac: 0, re: 2 } , '0.040': { ac: 1, re: 3 } , '0.065': { ac: 1, re: 4 } , '0.10': { ac: 2, re: 5 } , '0.15': { ac: 3, re: 6 } , '0.25': { ac: 5, re: 8 } , '0.40': { ac: 7, re: 10 } , '0.65': { ac: 10, re: 13 } , '1.0': 'up'   , '1.5': 'up'   , '2.5': 'up'   , '4.0': 'up'   , '6.5': 'up'   , '10': 'up'   , '15': 'up'   , '25': 'up'   , '40': 'up'   , '65': 'up'   , '100': 'up'   , '150': 'up'   , '250': 'up'   , '400': 'up'   , '650': 'up'   , '1000': 'up'   }
    };

    // Tightened Inspection Database
    const codeLettersOrder_tightened = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S'];
    const tightened_sampleSizes = {'A': 2, 'B': 3, 'C': 5, 'D': 8, 'E': 13, 'F': 20, 'G': 32, 'H': 50, 'J': 80, 'K': 125, 'L': 200, 'M': 315, 'N': 500, 'P': 800, 'Q': 1250, 'R': 2000, 'S': 3150};
    const tightened_rawMasterTableData = {
        'A': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': 'down', '1.0': 'down', '1.5': 'down', '2.5': 'down', '4.0': 'down', '6.5': 'down', '10': 'down', '15': 'down', '25': 'down', '40':    1, '65':    2, '100':    3, '150':    5, '250':    8, '400':   12, '650':   18, '1000':   27 },
        'B': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': 'down', '1.0': 'down', '1.5': 'down', '2.5': 'down', '4.0': 'down', '6.5':      0, '10': 'down', '15': 'down', '25':      1, '40':    2, '65':    3, '100':    5, '150':    8, '250':   12, '400':   18, '650':   27, '1000':   41 },
        'C': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': 'down', '1.0': 'down', '1.5': 'down', '2.5': 'down', '4.0':      0, '6.5': 'down', '10': 'down', '15':      1, '25':      2, '40':    3, '65':    5, '100':    8, '150':   12, '250':   18, '400':   27, '650':   41, '1000': 'up' },
        'D': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': 'down', '1.0': 'down', '1.5': 'down', '2.5':      0, '4.0': 'down', '6.5': 'down', '10':      1, '15':      2, '25':      3, '40':    5, '65':    8, '100':   12, '150':   18, '250':   27, '400':   41, '650': 'up', '1000': 'up' },
        'E': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': 'down', '1.0': 'down', '1.5':      0, '2.5':      1, '4.0': 'down', '6.5':      1, '10':      2, '15':      3, '25':      5, '40':    8, '65':   12, '100':   18, '150':   27, '250':   41, '400': 'up', '650': 'up', '1000': 'up' },
        'F': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65': 'down', '1.0':      0, '1.5': 'down', '2.5': 'down', '4.0':      1, '6.5':      2, '10':      3, '15':      5, '25':      8, '40':   12, '65':   18, '100': 'up', '150': 'up', '250': 'up', '400': 'up', '650': 'up', '1000': 'up' },
        'G': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40': 'down', '0.65':      0, '1.0': 'down', '1.5': 'down', '2.5':      1, '4.0':      2, '6.5':      3, '10':      5, '15':      8, '25':     12, '40':   18, '65': 'up', '100': 'up', '150': 'up', '250': 'up', '400': 'up', '650': 'up', '1000': 'up' },
        'H': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25': 'down', '0.40':      0, '0.65': 'down', '1.0': 'down', '1.5':      1, '2.5':      2, '4.0':      3, '6.5':      5, '10':      8, '15':     12, '25':     18, '40': 'up', '65': 'up', '100': 'up', '150': 'up', '250': 'up', '400': 'up', '650': 'up', '1000': 'up' },
        'J': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15': 'down', '0.25':      0, '0.40': 'down', '0.65': 'down', '1.0':      1, '1.5':      2, '2.5':      3, '4.0':      5, '6.5':      8, '10':     12, '15':     18, '25':   'up', '40': 'up', '65': 'up', '100': 'up', '150': 'up', '250': 'up', '400': 'up', '650': 'up', '1000': 'up' },
        'K': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10': 'down', '0.15':      0, '0.25': 'down', '0.40': 'down', '0.65':      1, '1.0':      2, '1.5':      3, '2.5':      5, '4.0':      8, '6.5':     12, '10':     18, '15':   'up', '25':   'up', '40': 'up', '65': 'up', '100': 'up', '150': 'up', '250': 'up', '400': 'up', '650': 'up', '1000': 'up' },
        'L': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065': 'down', '0.10':      0, '0.15': 'down', '0.25': 'down', '0.40':      1, '0.65':      2, '1.0':      3, '1.5':      5, '2.5':      8, '4.0':     12, '6.5':     18, '10':   'up', '15':   'up', '25':   'up', '40': 'up', '65': 'up', '100': 'up', '150': 'up', '250': 'up', '400': 'up', '650': 'up', '1000': 'up' },
        'M': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040': 'down', '0.065':      0, '0.10': 'down', '0.15': 'down', '0.25':      1, '0.40':      2, '0.65':      3, '1.0':      5, '1.5':      8, '2.5':     12, '4.0':     18, '6.5':   'up', '10':   'up', '15':   'up', '25':   'up', '40': 'up', '65': 'up', '100': 'up', '150': 'up', '250': 'up', '400': 'up', '650': 'up', '1000': 'up' },
        'N': { '0.010': 'down', '0.015': 'down', '0.025': 'down', '0.040':      0, '0.065': 'down', '0.10': 'down', '0.15':      1, '0.25':      2, '0.40':      3, '0.65':      5, '1.0':      8, '1.5':     12, '2.5':     18, '4.0':   'up', '6.5':   'up', '10':   'up', '15':   'up', '25':   'up', '40': 'up', '65': 'up', '100': 'up', '150': 'up', '250': 'up', '400': 'up', '650': 'up', '1000': 'up' },
        'P': { '0.010': 'down', '0.015': 'down', '0.025':      0, '0.040': 'down', '0.065': 'down', '0.10':      1, '0.15':      2, '0.25':      3, '0.40':      5, '0.65':      8, '1.0':     12, '1.5':     18, '2.5':   'up', '4.0':   'up', '6.5':   'up', '10':   'up', '15':   'up', '25':   'up', '40': 'up', '65': 'up', '100': 'up', '150': 'up', '250': 'up', '400': 'up', '650': 'up', '1000': 'up' },
        'Q': { '0.010': 'down', '0.015':      0, '0.025': 'down', '0.040': 'down', '0.065':      1, '0.10':      2, '0.15':      3, '0.25':      5, '0.40':      8, '0.65':     12, '1.0':     18, '1.5':   'up', '2.5':   'up', '4.0':   'up', '6.5':   'up', '10':   'up', '15':   'up', '25':   'up', '40': 'up', '65': 'up', '100': 'up', '150': 'up', '250': 'up', '400': 'up', '650': 'up', '1000': 'up' },
        'R': { '0.010':      0, '0.015':   'up', '0.025': 'down', '0.040':      1, '0.065':      2, '0.10':      3, '0.15':      5, '0.25':      8, '0.40':     12, '0.65':     18, '1.0':   'up', '1.5':   'up', '2.5':   'up', '4.0':   'up', '6.5':   'up', '10':   'up', '15':   'up', '25':   'up', '40': 'up', '65': 'up', '100': 'up', '150': 'up', '250': 'up', '400': 'up', '650': 'up', '1000': 'up' }
    };

    // Tabs routing (layout only)
    const tabEls = document.querySelectorAll('.tab');
    const sections = {
        distribution: document.getElementById('section-distribution'),
        plan: document.getElementById('section-plan'),
        reverse: document.getElementById('section-reverse'),
        kaiyi: document.getElementById('section-kaiyi'),
        c0: document.getElementById('section-c0'),
        'aql-ltpd': document.getElementById('section-aql-ltpd')
    };
    tabEls.forEach(t => t.addEventListener('click', () => {
        tabEls.forEach(z => z.classList.remove('active'));
        t.classList.add('active');
        Object.values(sections).forEach(s => { if (s) s.classList.remove('active'); });
        const key = t.getAttribute('data-target');
        const sec = sections[key];
        if (!sec) { console.warn('No section for key:', key); return; }
        sec.classList.add('active');
    }));

    // ===== Distribution page functionality =====
    const ctx = document.getElementById('ocChart').getContext('2d');
    const xMaxInit = parseFloat((document.getElementById('x_max')?.value) || '5');
    // Crosshair plugin for OC curves
    const ocCrosshairPlugin = {
        id: 'ocCrosshairPlugin',
        afterEvent: function(chart, args){
            const e = args.event; if (!e) return;
            chart._crosshair = chart._crosshair || { x: null, y: null };
            if (e.type==='mousemove'){ chart._crosshair.x = e.x; chart._crosshair.y = e.y; chart.draw(); }
            if (e.type==='mouseout'){ chart._crosshair.x = null; chart._crosshair.y = null; chart.draw(); }
        },
        afterDraw: function(chart){
            const cx = chart._crosshair && chart._crosshair.x; const cy = chart._crosshair && chart._crosshair.y;
            if (cx==null || cy==null) return;
            const ctx = chart.ctx; const area = chart.chartArea; if (!area) return;
            ctx.save();
            ctx.strokeStyle = 'rgba(199,202,207,0.5)';
            ctx.setLineDash([4,4]);
            // vertical line
            ctx.beginPath(); ctx.moveTo(cx, area.top); ctx.lineTo(cx, area.bottom); ctx.stroke();
            // horizontal line
            ctx.beginPath(); ctx.moveTo(area.left, cy); ctx.lineTo(area.right, cy); ctx.stroke();
            // read scale values
            const xScaleRef = chart.scales && chart.scales.x; const yScaleRef = chart.scales && chart.scales.y;
            if (xScaleRef && yScaleRef){
                const xVal = xScaleRef.getValueForPixel(cx);
                const yVal = yScaleRef.getValueForPixel(cy);
                if (isFinite(xVal) && isFinite(yVal)){
                    const xTxt = xVal.toFixed(2) + '%';
                    const yTxt = (yVal*100).toFixed(1) + '%';
                    const label = 'p=' + xTxt + ' , Pa=' + yTxt;
                    ctx.fillStyle = 'rgba(28,42,54,0.9)'; ctx.strokeStyle='rgba(64,84,102,0.9)';
                    ctx.setLineDash([]);
                    const pad = 6; ctx.font = '12px sans-serif';
                    const w = ctx.measureText(label).width + pad*2; const h = 20;
                    const bx = Math.min(Math.max(area.left, cx+8), area.right - w);
                    const by = Math.max(area.top, cy - h - 8);
                    ctx.beginPath(); ctx.roundRect ? ctx.roundRect(bx, by, w, h, 6) : ctx.rect(bx, by, w, h);
                    ctx.fill(); ctx.stroke();
                    ctx.fillStyle = '#e6e9ee'; ctx.fillText(label, bx+pad, by+14);
                }
            }
            ctx.restore();
        }
    };

    const ocChart = new Chart(ctx, {
        type: 'line',
        data: { datasets: [] },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            plugins: { 
                legend: { position: 'top', labels: { color: getThemeColors().text } },
                tooltip: {
                    enabled: true,
                    callbacks: {
                        label: function(context) {
                            const x = context.parsed && context.parsed.x;
                            const y = context.parsed && context.parsed.y;
                            const datasetLabel = context.dataset.label || '';
                            const xText = (isFinite(x) ? (+x).toFixed(x < 1 ? 3 : 2) : '-');
                            const yText = (isFinite(y) ? (y * 100).toFixed(1) : '-');
                            return `${datasetLabel}: p=${xText}%, Pa=${yText}%`;
                        }
                    }
                }
            },
            scales: {
                x: { type: 'linear', title: { display: true, text: 'Defect Rate (p%)', color: getThemeColors().text }, max: xMaxInit, grid: { color: getThemeColors().grid }, ticks: { color: getThemeColors().text } },
                y: { min: 0, max: 1, title: { display: true, text: 'Acceptance Probability (Pa%)', color: getThemeColors().text }, ticks: { callback: function(v){ return (v*100).toFixed(0)+'%'; }, color: getThemeColors().text }, grid: { color: getThemeColors().grid } }
            }
        },
        plugins: [ocCrosshairPlugin]
    });

    const distLotSizeEl = document.getElementById('dist_lot_size');
    const distNEl = document.getElementById('dist_n');
    const distCEl = document.getElementById('dist_c');
    const xMaxEl = document.getElementById('x_max');
    const btns = Array.from(document.querySelectorAll('[data-dist]'));

    // initial toggles: Hypergeometric, Binomial, Poisson ALL ON
    const distState = { hyper: true, binom: true, pois: true };
    syncButtons();

    btns.forEach(b => b.addEventListener('click', () => {
        const key = b.getAttribute('data-dist');
        distState[key] = !distState[key];
        syncButtons();
        updateDistributionChart();
    }));
    [distLotSizeEl, distNEl, distCEl, xMaxEl].forEach(el => el.addEventListener('input', () => {
        updateDistributionChart();
    }));


    function syncButtons() {
        btns.forEach(b => {
            const key = b.getAttribute('data-dist');
            b.classList.toggle('primary', !!distState[key]);
        });
    }

    function generatePValues(maxXPercent) {
        const step = 0.05; // percent step
        const num = Math.floor(maxXPercent / step) + 1;
        return Array.from({ length: num }, (_, i) => +(i * step).toFixed(2));
    }

    function getPaBinomial(n, c, p) {
        const result = jStat.binomial.cdf(c, n, p);
        return validateAcceptanceProbability(result, `getPaBinomial(n=${n}, c=${c}, p=${p})`);
    }
    function getPaPoisson(n, c, p) {
        const lambda = n * p;
        const result = jStat.poisson.cdf(c, lambda);
        return validateAcceptanceProbability(result, `getPaPoisson(n=${n}, c=${c}, p=${p})`);
    }
    function getPaHyper(N, n, c, p) {
        const m = Math.round(N * p); // number of defectives in lot
        // jStat.hypgeom.cdf(k, N, m, n) gives P(X <= k)
        const result = jStat.hypgeom.cdf(c, N, m, n);
        return validateAcceptanceProbability(result, `getPaHyper(N=${N}, n=${n}, c=${c}, p=${p})`);
    }

    function updateDistributionChart() {
        let N = parseInt(distLotSizeEl.value || '10000', 10);
        let n = parseInt(distNEl.value || '125', 10);
        let c = parseInt(distCEl.value || '2', 10);
        let maxX = parseFloat(xMaxEl.value || '5');
        if (isNaN(N) || N < 1 || isNaN(n) || n < 1 || isNaN(c) || c < 0 || isNaN(maxX) || maxX <= 0) return;

        const pValuesPercent = generatePValues(maxX);
        ocChart.options.scales.x.max = maxX;
        const datasets = [];

        if (distState.hyper) {
            const data = pValuesPercent.map(px => ({ x: px, y: getPaHyper(N, n, c, px/100) }));
            datasets.push({ label: 'Hypergeometric', data, borderColor: 'rgba(241,196,15,1)', backgroundColor: 'rgba(241,196,15,0.25)', borderWidth: 2, pointRadius: 0, tension: 0.1 });
        }
        if (distState.binom) {
            const data = pValuesPercent.map(px => ({ x: px, y: getPaBinomial(n, c, px/100) }));
            datasets.push({ label: 'Binomial', data, borderColor: 'rgba(46,204,113,1)', backgroundColor: 'rgba(46,204,113,0.25)', borderWidth: 2, pointRadius: 0, tension: 0.1 });
        }
        if (distState.pois) {
            const data = pValuesPercent.map(px => ({ x: px, y: getPaPoisson(n, c, px/100) }));
            datasets.push({ label: 'Poisson', data, borderColor: 'rgba(231,76,60,1)', backgroundColor: 'rgba(231,76,60,0.25)', borderWidth: 2, pointRadius: 0, tension: 0.1 });
        }

        ocChart.data.datasets = datasets;
        ocChart.update();
    }

    // ===== Export utilities (unified background + proportional scaling) =====
    function getCssVar(name){ try { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); } catch(e){ return ''; } }
    function getUiChartBg(){
        // Prefer panel-2; fallback to panel; final fallback to a dark tone
        return getCssVar('--panel-2') || getCssVar('--panel') || '#111c26';
    }
    // Enhanced theme color function for export with consistent dark theme colors
    function getExportThemeColors() {
        // Always use dark theme colors for consistent export across all themes
        return {
            text: '#e6e9ee', // Light text for better contrast on dark background
            grid: 'rgba(199,202,207,0.4)', // Visible grid lines
            background: getUiChartBg()
        };
    }
    
    function exportChartHiRes(chart, baseName){
        if (!chart) return;
        var scale = 3; // reduce memory usage
        var srcW = chart.width, srcH = chart.height;
        var offCanvas = document.createElement('canvas'); offCanvas.width = srcW*scale; offCanvas.height = srcH*scale;
        var offCtx = offCanvas.getContext('2d');
        // Build minimal high-res config
        var type = (chart.config && chart.config.type) ? chart.config.type : 'line';
        var srcData = chart.data || { datasets: [] };
        var datasets = [];
        for (var i=0; i<(srcData.datasets?srcData.datasets.length:0); i++){
            var ds = srcData.datasets[i] || {};
            var cleanData = Array.isArray(ds.data) ? ds.data.map(function(p){ return { x: p.x, y: p.y }; }) : [];
            var pointRadius = ds.type === 'scatter' ? (ds.pointRadius||4)*scale : (ds.pointRadius||0)*scale;
            datasets.push({ label: ds.label || '', data: cleanData, borderColor: ds.borderColor || '#1783FF', backgroundColor: ds.backgroundColor || 'rgba(23,131,255,0.25)', borderWidth: (ds.borderWidth||2)*scale, pointRadius: pointRadius, tension: ds.tension||0.1 });
        }
        var xTitleObj = (((chart.options||{}).scales||{}).x||{}).title || {};
        var yTitleObj = (((chart.options||{}).scales||{}).y||{}).title || {};
        
        // Get enhanced export colors
        const exportColors = getExportThemeColors();
        
        // plugin to paint full-canvas background before Chart draws (avoids transparent margins)
        var bgPlugin = { id:'exportBg', beforeDraw: function(c){ var ctx=c.ctx; ctx.save(); ctx.fillStyle = exportColors.background; ctx.fillRect(0,0,c.width,c.height); ctx.restore(); } };
        var padPx = Math.round(Math.min(offCanvas.width, offCanvas.height) * 0.05);
        // Get Y-axis range from original chart
        var yMin = (((chart.options||{}).scales||{}).y||{}).min;
        var yMax = (((chart.options||{}).scales||{}).y||{}).max;
        var yTicksCallback = (((chart.options||{}).scales||{}).y||{}).ticks?.callback;
        
        var options = { responsive:false, maintainAspectRatio:false, animation:false, devicePixelRatio:1,
            layout:{ padding:{ left:padPx, right:padPx, top:padPx, bottom:padPx } },
            plugins:{ legend:{ display:true, labels:{ color: exportColors.text, font:{ size:12*scale } } }, tooltip:{ enabled:false } },
            scales:{ x:{ type:'linear', title:{ display: !!xTitleObj.text, text: xTitleObj.text || 'Defect Rate (p%)', color: exportColors.text, font:{ size:12*scale } }, grid:{ color: exportColors.grid }, ticks:{ color: exportColors.text, font:{ size:12*scale } }, border: { color: exportColors.grid } }, y:{ min:yMin, max:yMax, title:{ display: !!yTitleObj.text, text: yTitleObj.text || 'Acceptance Probability (Pa%)', color: exportColors.text, font:{ size:12*scale } }, grid:{ color: exportColors.grid }, ticks:{ color: exportColors.text, font:{ size:12*scale }, callback: yTicksCallback }, border: { color: exportColors.grid } } }, elements:{ line:{ borderWidth:2*scale }, point:{ radius:4*scale } } };
        var tempChart = null; try { 
            // Handle mixed chart types (line + scatter)
            var chartConfig = { data: { datasets: datasets }, options: options, plugins: [bgPlugin] };
            // If we have mixed types, use 'line' as base type
            chartConfig.type = type;
            tempChart = new Chart(offCtx, chartConfig); 
        } catch(e) { console.error('Chart creation error:', e); }
        var filename = baseName + '.png';
        if (offCanvas.toBlob) {
            offCanvas.toBlob(function(blob){ var url = URL.createObjectURL(blob); var a=document.createElement('a'); a.href=url; a.download=filename; a.click(); setTimeout(function(){ URL.revokeObjectURL(url); }, 1000); try{ tempChart && tempChart.destroy(); }catch(_){ } }, 'image/png');
        } else {
            var url = offCanvas.toDataURL('image/png'); var a=document.createElement('a'); a.href=url; a.download=filename; a.click(); try{ tempChart && tempChart.destroy(); }catch(_){ }
        }
    }

    // Export handlers
    document.getElementById('export_png').onclick = () => { exportChartHiRes(ocChart, 'oc_chart'); };
    document.getElementById('export_csv').onclick = () => {
        let csv = 'label,x_defect_rate_percent,y_acceptance_prob\n';
        ocChart.data.datasets.forEach(ds => {
            ds.data.forEach(p => { csv += `${ds.label},${p.x},${p.y}\n`; });
        });
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'oc_chart.csv'; a.click();
        URL.revokeObjectURL(url);
    };
    // Left-side export buttons removed; use toolbar buttons only

    // initial draw
    updateDistributionChart();

    // ===== Multiple Plan Comparison functionality =====
    const planCanvasEl = document.getElementById('ocChartPLAN');
    const planCtx = planCanvasEl ? planCanvasEl.getContext('2d') : null;
    let planChart = null;
    const planNInput = document.getElementById('plan_n_input');
    const planCInput = document.getElementById('plan_c_input');
    const planAqlInput = document.getElementById('plan_aql_input');
    const planLabelInput = document.getElementById('plan_label_input');
    const addPlanBtn = document.getElementById('add-plan-btn');
    const clearAllBtn = document.getElementById('clear-all-btn');
    const planListEl = document.getElementById('plan-list');
    const planXMaxEl = document.getElementById('plan_x_axis_max_input');
    const planExportPngBtn = document.getElementById('plan_export_png');
    const planExportCsvBtn = document.getElementById('plan_export_csv');
    const planImportBtn = document.getElementById('plan_import_btn');
    const planColors = ['#1783FF','#2ecc71','#f1c40f','#e74c3c','#9b59b6','#1abc9c','#e67e22','#95a5a6'];
    let planCounter = 1;
    let samplingPlans = [];
    let currentCurveType = 'oc'; // Track current curve type

    function ensurePlanChart(){
        if (planChart) return planChart;
        var legendLabels = { color: getThemeColors().text, filter: function(item, chart){ var ds = chart.datasets && chart.datasets[item.datasetIndex]; return !(ds && ds.type==='scatter'); } };
        var plugins = { legend: { display: true, labels: legendLabels } };
        var xScale = { type: 'linear', title: { display: true, text: 'Defect Rate (p%)', color: getThemeColors().text }, grid: { color: getThemeColors().grid }, ticks: { color: getThemeColors().text } };
        var yTicks = { callback: function(v){ return (v*100).toFixed(0)+'%'; } };
        var yScale = { min: 0, max: 1, title: { display: true, text: 'Acceptance Probability (Pa%)', color: getThemeColors().text }, ticks: Object.assign({}, yTicks, { color: getThemeColors().text }), grid: { color: getThemeColors().grid } };
        var scales = { x: xScale, y: yScale };
        // crosshair and tooltip: enable tooltip for all datasets
        plugins.tooltip = {
            enabled: true,
            callbacks: {
                label: function(context){
                    var x = context.parsed && context.parsed.x; var y = context.parsed && context.parsed.y;
                    var datasetLabel = context.dataset.label || '';
                    var xTxt = (isFinite(x)?(+x).toFixed(x<1?3:2):'-');
                    
                    // Format y value based on current curve type
                    var yTxt;
                    if (currentCurveType === 'aoq') {
                        // AOQ is already in percentage format
                        yTxt = (isFinite(y)?y.toFixed(2):'-') + '%';
                    } else if (currentCurveType === 'ati') {
                        // ATI is in actual count, no percentage
                        yTxt = (isFinite(y)?y.toFixed(0):'-');
                    } else {
                        // OC curve: convert from 0-1 to percentage
                        yTxt = (isFinite(y)?(y*100).toFixed(1):'-') + '%';
                    }
                    
                    // Special handling for AQL scatter markers
                    if (context.dataset && context.dataset.type==='scatter') {
                        var base = (context.dataset._aqlLabel || 'AQL');
                        var yLabel = 'Pa';
                        if (currentCurveType === 'aoq') {
                            yLabel = 'AOQ';
                        } else if (currentCurveType === 'ati') {
                            yLabel = 'ATI';
                        }
                        return base+': p='+xTxt+'% , '+yLabel+'='+yTxt;
                    }
                    
                    // Regular line chart tooltip
                    var yLabel = 'y';
                    if (currentCurveType === 'aoq') {
                        yLabel = 'AOQ';
                    } else if (currentCurveType === 'ati') {
                        yLabel = 'ATI';
                    } else {
                        yLabel = 'Pa';
                    }
                    return datasetLabel+': p='+xTxt+'% , '+yLabel+'='+yTxt;
                }
            }
        };
        var options = { responsive: true, maintainAspectRatio: false, animation: false, plugins: plugins, scales: scales };
        var data = { datasets: [] };
        // custom crosshair plugin
        var crosshairPlugin = {
            id: 'crosshairPlugin',
            afterEvent: function(chart, args){
                var e = args.event; if (!e) return;
                chart._crosshair = chart._crosshair || { x: null, y: null };
                if (e.type==='mousemove'){ chart._crosshair.x = e.x; chart._crosshair.y = e.y; chart.draw(); }
                if (e.type==='mouseout'){ chart._crosshair.x = null; chart._crosshair.y = null; chart.draw(); }
            },
            afterDraw: function(chart){
                var cx = chart._crosshair && chart._crosshair.x; var cy = chart._crosshair && chart._crosshair.y;
                if (cx==null || cy==null) return;
                var ctx = chart.ctx; var area = chart.chartArea; if (!area) return;
                ctx.save();
                ctx.strokeStyle = 'rgba(199,202,207,0.5)';
                ctx.setLineDash([4,4]);
                // vertical line
                ctx.beginPath(); ctx.moveTo(cx, area.top); ctx.lineTo(cx, area.bottom); ctx.stroke();
                // horizontal line
                ctx.beginPath(); ctx.moveTo(area.left, cy); ctx.lineTo(area.right, cy); ctx.stroke();
                // read scale values
                var xScaleRef = chart.scales && chart.scales.x; var yScaleRef = chart.scales && chart.scales.y;
                if (xScaleRef && yScaleRef){
                    var xVal = xScaleRef.getValueForPixel(cx);
                    var yVal = yScaleRef.getValueForPixel(cy);
                    if (isFinite(xVal) && isFinite(yVal)){
                        // Format label based on current curve type
                        var xTxt = xVal.toFixed(2) + '%';
                        var yTxt, yLabel;
                        
                        if (currentCurveType === 'aoq') {
                            yLabel = 'AOQ';
                            yTxt = yVal.toFixed(2) + '%';
                        } else if (currentCurveType === 'ati') {
                            yLabel = 'ATI';
                            yTxt = yVal.toFixed(0);
                        } else {
                            yLabel = 'Pa';
                            yTxt = (yVal*100).toFixed(1) + '%';
                        }
                        
                        var label = 'p=' + xTxt + ' , ' + yLabel + '=' + yTxt;
                        ctx.fillStyle = 'rgba(28,42,54,0.9)'; ctx.strokeStyle='rgba(64,84,102,0.9)';
                        ctx.setLineDash([]);
                        var pad = 6; ctx.font = '12px sans-serif';
                        var w = ctx.measureText(label).width + pad*2; var h = 20;
                        var bx = Math.min(Math.max(area.left, cx+8), area.right - w);
                        var by = Math.max(area.top, cy - h - 8);
                        ctx.beginPath(); ctx.roundRect ? ctx.roundRect(bx, by, w, h, 6) : ctx.rect(bx, by, w, h);
                        ctx.fill(); ctx.stroke();
                        ctx.fillStyle = '#e6e9ee'; ctx.fillText(label, bx+pad, by+14);
                    }
                }
                ctx.restore();
            }
        };
        // Create the comparison chart with an instance-scoped crosshair plugin
        planChart = new Chart(planCtx, { type: 'line', data: data, options: options, plugins: [crosshairPlugin] });
        return planChart;
    }
    function genPValues(maxX){
        var step = 0.05; var num = Math.floor(maxX/step)+1; var arr = new Array(num);
        for (var i=0;i<num;i++){ arr[i] = +(i*step).toFixed(2); }
        return arr;
    }
    // Unified probability calculation function, selects correct calculation method based on distribution type
    function computePlanPa(dist, N, n, c, p) {
        let result;
        if (dist === 'binom') result = jStat.binomial.cdf(c, n, p);
        else if (dist === 'pois') result = jStat.poisson.cdf(c, n * p);
        else if (dist === 'hyper') {
            const m = Math.round(N * p);
            result = jStat.hypgeom.cdf(c, N, m, n);
        } else {
            // Default to binomial distribution (backward compatibility)
            result = jStat.binomial.cdf(c, n, p);
        }
        return validateAcceptanceProbability(result, `computePlanPa(dist=${dist}, N=${N}, n=${n}, c=${c}, p=${p})`);
    }
    
    function updatePlanChart(curveType = 'oc'){
        if (!planCtx) return; ensurePlanChart();
        // Update current curve type
        currentCurveType = curveType;
        var maxX = parseFloat(planXMaxEl.value||'5'); planChart.options.scales.x.max = maxX;
        var xs = genPValues(maxX);
        var datasets = [];
        
        // Update chart title and y-axis label based on curve type
        if (curveType === 'aoq') {
            planChart.options.scales.y.title.text = 'Average Outgoing Quality (AOQ%)';
            planChart.options.scales.y.ticks.callback = function(v){ return v.toFixed(2)+'%'; };
            // Reset Y-axis range for AOQ - will be set dynamically
            planChart.options.scales.y.min = 0;
            planChart.options.scales.y.max = undefined;
        } else if (curveType === 'ati') {
            planChart.options.scales.y.title.text = 'Average Total Inspection (ATI)';
            planChart.options.scales.y.ticks.callback = function(v){ return v.toFixed(0); };
            // Reset Y-axis range for ATI - will be set dynamically
            planChart.options.scales.y.min = 0;
            planChart.options.scales.y.max = undefined;
        } else {
            planChart.options.scales.y.title.text = 'Acceptance Probability (Pa%)';
            planChart.options.scales.y.ticks.callback = function(v){ return (v*100).toFixed(0)+'%'; };
            // Reset Y-axis range for OC curves
            planChart.options.scales.y.min = 0;
            planChart.options.scales.y.max = 1;
        }
        
        for (var idx=0; idx<samplingPlans.length; idx++){
            var plan = samplingPlans[idx];
            var color = plan.color || planColors[idx % planColors.length];
            var data = [];
            // Use correct distribution type and parameters
            var dist = plan.dist || 'binom'; // Default binomial distribution
            var N = plan.N || 10000; // Default large lot size
            
            for (var j=0;j<xs.length;j++){ 
                var px = xs[j]; 
                var pa = computePlanPa(dist, N, plan.n, plan.c, px/100);
                var y;
                
                if (curveType === 'aoq') {
                    // AOQ = p * Pa * (N-n)/N
                    y = (px/100) * pa * (N - plan.n) / N * 100; // Convert to percentage
                } else if (curveType === 'ati') {
                    // ATI = n + (1-Pa) * (N-n)
                    y = plan.n + (1 - pa) * (N - plan.n);
                } else {
                    // OC curve
                    y = pa;
                }
                
                data.push({ x:px, y: y }); 
            }
            
            var label = plan.label;
            if (curveType === 'aoq') label += ' (AOQ)';
            else if (curveType === 'ati') label += ' (ATI)';
            
            datasets.push({ 
                label: label, 
                data: data, 
                borderColor: color, 
                backgroundColor: color+'33', 
                borderWidth:2, 
                pointRadius:0, 
                tension:0.1 
            });
            
            // Add AQL marker if available (only for OC curves)
            if (curveType === 'oc' && plan.aql!=null && isFinite(+plan.aql)){
                var aqlX = +plan.aql; if (aqlX>=0){
                    var paAtAql = computePlanPa(dist, N, plan.n, plan.c, aqlX/100);
                    datasets.push({
                        type: 'scatter',
                        // Hide from legend; use tooltip only
                        label: '',
                        data: [{ x: aqlX, y: paAtAql }],
                        pointRadius: 5,
                        pointHoverRadius: 6,
                        showLine: false,
                        borderColor: color,
                        pointBackgroundColor: color,
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 1,
                        _aqlLabel: 'AQL'
                    });
                }
            } else if (curveType === 'ati' && plan.aql!=null && isFinite(+plan.aql)){
                // Add AQL marker for ATI curves with correct ATI value
                var aqlX = +plan.aql; if (aqlX>=0){
                    var paAtAql = computePlanPa(dist, N, plan.n, plan.c, aqlX/100);
                    var atiAtAql = plan.n + (1 - paAtAql) * (N - plan.n);
                    datasets.push({
                        type: 'scatter',
                        // Hide from legend; use tooltip only
                        label: '',
                        data: [{ x: aqlX, y: atiAtAql }],
                        pointRadius: 5,
                        pointHoverRadius: 6,
                        showLine: false,
                        borderColor: color,
                        pointBackgroundColor: color,
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 1,
                        _aqlLabel: 'AQL'
                    });
                }
            } else if (curveType === 'aoq' && plan.aql!=null && isFinite(+plan.aql)){
                // Add AQL marker for AOQ curves with correct AOQ value
                var aqlX = +plan.aql; if (aqlX>=0){
                    var paAtAql = computePlanPa(dist, N, plan.n, plan.c, aqlX/100);
                    var aoqAtAql = (aqlX/100) * paAtAql * (N - plan.n) / N * 100;
                    datasets.push({
                        type: 'scatter',
                        // Hide from legend; use tooltip only
                        label: '',
                        data: [{ x: aqlX, y: aoqAtAql }],
                        pointRadius: 5,
                        pointHoverRadius: 6,
                        showLine: false,
                        borderColor: color,
                        pointBackgroundColor: color,
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 1,
                        _aqlLabel: 'AQL'
                    });
                }
            }
        }
        planChart.data.datasets = datasets; 
        
        // Calculate and set dynamic Y-axis range for AOQ and ATI curves
        if (curveType === 'aoq' || curveType === 'ati') {
            var maxY = 0;
            for (var i = 0; i < datasets.length; i++) {
                var dataset = datasets[i];
                for (var j = 0; j < dataset.data.length; j++) {
                    var y = dataset.data[j].y;
                    if (isFinite(y) && y > maxY) {
                        maxY = y;
                    }
                }
            }
            // Add 10% padding to the maximum value
            if (maxY > 0) {
                planChart.options.scales.y.max = maxY * 1.1;
            }
        }
        
        planChart.update();
        renderPlanList();
        
        // Update button states
        updateCurveButtons(curveType);
    }

    // import from global queue
    // removed: cross-page import feature
    function renderPlanList(){ 
        if (!planListEl) return; 
        planListEl.innerHTML=''; 
        for (var i=0;i<samplingPlans.length;i++){ 
            var p=samplingPlans[i]; 
            var li=document.createElement('li'); 
            li.style.display='flex'; 
            li.style.justifyContent='space-between'; 
            li.style.alignItems='center'; 
            li.style.gap='8px'; 
            li.style.padding='8px'; 
            li.style.border='1px solid var(--border)'; 
            li.style.borderRadius='8px'; 
            var aqlTxt = (p.aql==null? 'No AQL' : ('AQL='+(+p.aql).toFixed(2)+'%')); 
            var distTxt = p.dist ? (p.dist === 'hyper' ? 'Hypergeometric' : (p.dist === 'binom' ? 'Binomial' : 'Poisson')) : 'Binomial';
            var nTxt = p.N && p.dist === 'hyper' ? ', N='+p.N : '';
            li.innerHTML = '<span style="color:'+p.color+'">'+p.label+': n='+p.n+', c='+p.c+', '+aqlTxt+' ('+distTxt+nTxt+')</span><button class="btn" data-del="'+i+'">×</button>'; 
            planListEl.appendChild(li); 
        } 
    }
    if (planListEl) { planListEl.addEventListener('click', function(e){ var t=e.target; if (t && t.getAttribute('data-del')){ var idx=+t.getAttribute('data-del'); samplingPlans.splice(idx,1); updatePlanChart(currentCurveType); }}); }
    if (addPlanBtn) { addPlanBtn.addEventListener('click', function(){
        const n = parseInt(planNInput.value,10), c = parseInt(planCInput.value,10); const aqlStr = planAqlInput.value.trim(); const label = (planLabelInput.value.trim()||`Plan ${planCounter++}`);
        if (!(n>0) || !(c>=0) || n<c) { alert('Please enter valid n and c (n>0, c>=0, n>=c).'); return; }
        let aql = null; if (aqlStr !== '') { const num = parseFloat(aqlStr); if (!(num>=0)) { alert('AQL must be a non-negative number.'); return; } aql = num; }
        const color = planColors[samplingPlans.length % planColors.length];
        // Manually added plans default to binomial distribution
        samplingPlans.push({ n, c, aql, label, color, dist: 'binom', N: 10000, source: 'manual' });
        planLabelInput.value=''; planAqlInput.value=''; updatePlanChart(currentCurveType);
    }); }
    if (clearAllBtn) { clearAllBtn.addEventListener('click', function(){ samplingPlans = []; planCounter=1; updatePlanChart(currentCurveType); }); }
    
    // Curve type buttons
    const showOcBtn = document.getElementById('show-oc-btn');
    const showAoqBtn = document.getElementById('show-aoq-btn');
    const showAtiBtn = document.getElementById('show-ati-btn');
    
    // Function to update button states
    function updateCurveButtons(activeType) {
        [showOcBtn, showAoqBtn, showAtiBtn].forEach(btn => {
            if (btn) {
                btn.classList.remove('primary');
                btn.classList.add('btn');
            }
        });
        
        if (activeType === 'oc' && showOcBtn) showOcBtn.classList.add('primary');
        else if (activeType === 'aoq' && showAoqBtn) showAoqBtn.classList.add('primary');
        else if (activeType === 'ati' && showAtiBtn) showAtiBtn.classList.add('primary');
    }
    
    if (showOcBtn) { 
        showOcBtn.addEventListener('click', function(){ 
            if (samplingPlans.length === 0) { 
                alert('Please add at least one plan first.'); 
                return; 
            }
            updatePlanChart('oc'); 
            updateCurveButtons('oc');
        }); 
    }
    
    if (showAoqBtn) { 
        showAoqBtn.addEventListener('click', function(){ 
            if (samplingPlans.length === 0) { 
                alert('Please add at least one plan first.'); 
                return; 
            }
            updatePlanChart('aoq'); 
            updateCurveButtons('aoq');
        }); 
    }
    
    if (showAtiBtn) { 
        showAtiBtn.addEventListener('click', function(){ 
            if (samplingPlans.length === 0) { 
                alert('Please add at least one plan first.'); 
                return; 
            }
            updatePlanChart('ati'); 
            updateCurveButtons('ati');
        }); 
    }
    if (planXMaxEl) { planXMaxEl.addEventListener('input', function(){ updatePlanChart(currentCurveType); }); }
    if (planExportPngBtn) { planExportPngBtn.addEventListener('click', function(){ ensurePlanChart(); updatePlanChart(currentCurveType); setTimeout(function(){ exportChartHiRes(planChart, 'plan_comparison'); }, 100); }); }
    if (planExportCsvBtn) { planExportCsvBtn.addEventListener('click', function(){ ensurePlanChart(); var csv='label,x_defect_rate_percent,y_acceptance_prob\n'; for (var di=0; di<planChart.data.datasets.length; di++){ var ds=planChart.data.datasets[di]; if (ds.type==='scatter') continue; for (var pi=0; pi<ds.data.length; pi++){ var p=ds.data[pi]; csv += ds.label+','+p.x+','+p.y+'\n'; } } var blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); var url=URL.createObjectURL(blob); var a=document.createElement('a'); a.href=url; a.download='plan_comparison.csv'; a.click(); URL.revokeObjectURL(url); }); }
    // Initialize plan chart on page load to ensure tooltip works
    if (planCtx) {
        ensurePlanChart();
        updatePlanChart('oc');
        updateCurveButtons('oc');
    }
    
    if (planImportBtn) { planImportBtn.addEventListener('click', function(){
        var queue = window.planComparisonQueue || [];
        if (!Array.isArray(queue) || queue.length===0) { alert('No exported plans found. Use Export to Plan Comparison on other pages first.'); return; }
        var added = 0;
        for (var i=0;i<queue.length;i++){
            var q = queue[i]; if (!q) continue;
            var n = parseInt(q.n,10), c = parseInt(q.c,10);
            if (!(n>0) || !(c>=0) || n<c) continue;
            var aql = (q.aql==null || isNaN(+q.aql)) ? null : +q.aql;
            var label = q.label || ('Imported '+(i+1));
            var dist = q.dist || 'binom'; // Default binomial distribution
            var N = q.N || 10000; // Default large lot size
            const color = planColors[samplingPlans.length % planColors.length];
            samplingPlans.push({ n, c, aql, label, color, dist, N, source: q.source });
            added++;
        }
        if (added===0) { alert('No valid plans in queue to import.'); return; }
        window.planComparisonQueue = [];
        updatePlanChart(currentCurveType);
        renderPlanList();
        alert('Imported '+added+' plan(s). Note: Plans from different pages may use different probability distributions (Hypergeometric/Binomial/Poisson).');
    }); }

    // ===== Reverse page functionality =====
    const revLotEl = document.getElementById('rev_lot_size');
    const revNEl = document.getElementById('rev_n');
    const revCEl = document.getElementById('rev_c');
    const revAqlEl = document.getElementById('rev_aql');
    const revTargetPaEl = document.getElementById('rev_target_pa');
    const revTargetParamSel = document.getElementById('rev_target_param');
    const revDistSel = document.getElementById('rev_dist_select');
    const revCalcBtn = document.getElementById('rev_calc_btn');
    const revClearBtn = document.getElementById('rev_clear_btn');
    const revErrEl = document.getElementById('rev_error');
    const revXMaxEl = document.getElementById('rev_x_max');
    const revCtx = document.getElementById('ocChartREV')?.getContext('2d');
    let revChart = null; let revLastPlan = null; // {N,n,c,aql,dist,targetPa}
    let revLastBracket = null; let revLastTargetParam = null; let revPlanChoice = 'upper';

    function ensureRevChart() {
        if (revChart) return revChart;
        
        // Crosshair plugin for Reverse page
        const revCrosshairPlugin = {
            id: 'revCrosshairPlugin',
            afterEvent: function(chart, args){
                const e = args.event; if (!e) return;
                chart._crosshair = chart._crosshair || { x: null, y: null };
                if (e.type==='mousemove'){ chart._crosshair.x = e.x; chart._crosshair.y = e.y; chart.draw(); }
                if (e.type==='mouseout'){ chart._crosshair.x = null; chart._crosshair.y = null; chart.draw(); }
            },
            afterDraw: function(chart){
                const cx = chart._crosshair && chart._crosshair.x; const cy = chart._crosshair && chart._crosshair.y;
                if (cx==null || cy==null) return;
                const ctx = chart.ctx; const area = chart.chartArea; if (!area) return;
                ctx.save();
                ctx.strokeStyle = 'rgba(199,202,207,0.5)';
                ctx.setLineDash([4,4]);
                // vertical line
                ctx.beginPath(); ctx.moveTo(cx, area.top); ctx.lineTo(cx, area.bottom); ctx.stroke();
                // horizontal line
                ctx.beginPath(); ctx.moveTo(area.left, cy); ctx.lineTo(area.right, cy); ctx.stroke();
                // read scale values
                const xScaleRef = chart.scales && chart.scales.x; const yScaleRef = chart.scales && chart.scales.y;
                if (xScaleRef && yScaleRef){
                    const xVal = xScaleRef.getValueForPixel(cx);
                    const yVal = yScaleRef.getValueForPixel(cy);
                    if (isFinite(xVal) && isFinite(yVal)){
                        const xTxt = xVal.toFixed(2) + '%';
                        const yTxt = (yVal*100).toFixed(1) + '%';
                        const label = 'p=' + xTxt + ' , Pa=' + yTxt;
                        ctx.fillStyle = 'rgba(28,42,54,0.9)'; ctx.strokeStyle='rgba(64,84,102,0.9)';
                        ctx.setLineDash([]);
                        const pad = 6; ctx.font = '12px sans-serif';
                        const w = ctx.measureText(label).width + pad*2; const h = 20;
                        const bx = Math.min(Math.max(area.left, cx+8), area.right - w);
                        const by = Math.max(area.top, cy - h - 8);
                        ctx.beginPath(); ctx.roundRect ? ctx.roundRect(bx, by, w, h, 6) : ctx.rect(bx, by, w, h);
                        ctx.fill(); ctx.stroke();
                        ctx.fillStyle = '#e6e9ee'; ctx.fillText(label, bx+pad, by+14);
                    }
                }
                ctx.restore();
            }
        };
        
        revChart = new Chart(revCtx, {
            type: 'line', data: { datasets: [] }, options: {
                responsive: true, maintainAspectRatio: false, animation: false,
                plugins: { 
                    legend: { display: true, labels: { color: getThemeColors().text } },
                    tooltip: {
                        enabled: true,
                        callbacks: {
                            label: function(context) {
                                const x = context.parsed && context.parsed.x;
                                const y = context.parsed && context.parsed.y;
                                const datasetLabel = context.dataset.label || '';
                                const xText = (isFinite(x) ? (+x).toFixed(x < 1 ? 3 : 2) : '-');
                                const yText = (isFinite(y) ? (y * 100).toFixed(1) : '-');
                                return `${datasetLabel}: p=${xText}%, Pa=${yText}%`;
                            }
                        }
                    }
                },
                scales: {
                    x: { type: 'linear', title: { display: true, text: 'Defect Rate (p%)', color: getThemeColors().text }, grid: { color: getThemeColors().grid }, ticks: { color: getThemeColors().text }, border: { color: getThemeColors().grid } },
                    y: { min: 0, max: 1, title: { display: true, text: 'Acceptance Probability (Pa%)', color: getThemeColors().text }, ticks: { callback: function(v){ return (v*100).toFixed(0)+'%'; }, color: getThemeColors().text }, grid: { color: getThemeColors().grid }, border: { color: getThemeColors().grid } }
                }
            },
            plugins: [revCrosshairPlugin]
        });
        return revChart;
    }
    function revComputePa(dist, N, n, c, p) {
        let result;
        if (dist==='binom') result = jStat.binomial.cdf(c, n, p);
        else if (dist==='pois') result = jStat.poisson.cdf(c, n*p);
        else {
            const m = Math.round(N*p); 
            result = jStat.hypgeom.cdf(c, N, m, n);
        }
        return validateAcceptanceProbability(result, `revComputePa(dist=${dist}, N=${N}, n=${n}, c=${c}, p=${p})`);
    }
    function revGeneratePValues(maxXPercent) {
        const step = 0.05; const num = Math.floor(maxXPercent/step)+1; return Array.from({length:num},(_,i)=>+(i*step).toFixed(2));
    }
    function drawRevChart(N, n, c, aql, dist) {
        const maxX = parseFloat(revXMaxEl.value||'5'); const xs = revGeneratePValues(maxX); ensureRevChart(); revChart.options.scales.x.max = maxX;
        const data = xs.map(px=>({x:px, y: revComputePa(dist, N, n, c, px/100)}));
        revChart.data.datasets = [{ label:`Reverse (n=${n}, c=${c}, AQL=${aql.toFixed(3)}%, N=${N})`, data, borderColor:'rgba(120,99,255,1)', backgroundColor:'rgba(120,99,255,0.25)', borderWidth:2, pointRadius:0, tension:0.1 }];
        revChart.update();
    }
    function renderPlanLines(lower, upper, label, dist){
        const fmt = (v)=> v==null? '': `${label}=${v.value}`;
        const fmtPa = (v)=> v==null? '': `Pa=${(v.pa*100).toFixed(2)}%`;
        const distName = (dist==='hyper'?'Hypergeometric':(dist==='binom'?'Binomial':'Poisson'));
        let html = '';
        if (lower) html += `<div id="rev_plan1" style="cursor:pointer; padding: 8px; border: 1px solid #424242; border-radius: 4px; margin: 4px 0; background: rgba(60, 60, 60, 0.8); color: white; font-weight: bold;"><strong>Plan1</strong>  ${fmt(lower)}  ·  ${fmtPa(lower)}  ·  ${distName}</div>`;
        if (upper) html += `<div id="rev_plan2" style="cursor:pointer; padding: 8px; border: 1px solid #424242; border-radius: 4px; margin: 4px 0; background: rgba(60, 60, 60, 0.8); color: white; font-weight: bold;"><strong>Plan2</strong>  ${fmt(upper)}  ·  ${fmtPa(upper)}  ·  ${distName}</div>`;
        return html || '';
    }
    function attachPlanChoiceHandlers(){
        const p1 = document.getElementById('rev_plan1');
        const p2 = document.getElementById('rev_plan2');
        if (p1) {
            p1.setAttribute('role','button');
            p1.setAttribute('tabindex','0');
            p1.style.userSelect = 'none';
            p1.style.pointerEvents = 'auto';
            p1.addEventListener('click', (e)=>{ e.preventDefault(); choosePlan('lower'); });
            p1.addEventListener('keydown', (e)=>{ if (e.key==='Enter' || e.key===' ') { e.preventDefault(); choosePlan('lower'); } });
            // Add hover effect
            p1.addEventListener('mouseenter', () => {
                p1.style.background = 'rgba(80, 80, 80, 0.8)';
            });
            p1.addEventListener('mouseleave', () => {
                p1.style.background = 'rgba(60, 60, 60, 0.8)';
            });
        }
        if (p2) {
            p2.setAttribute('role','button');
            p2.setAttribute('tabindex','0');
            p2.style.userSelect = 'none';
            p2.style.pointerEvents = 'auto';
            p2.addEventListener('click', (e)=>{ e.preventDefault(); choosePlan('upper'); });
            p2.addEventListener('keydown', (e)=>{ if (e.key==='Enter' || e.key===' ') { e.preventDefault(); choosePlan('upper'); } });
            // Add hover effect
            p2.addEventListener('mouseenter', () => {
                p2.style.background = 'rgba(80, 80, 80, 0.8)';
            });
            p2.addEventListener('mouseleave', () => {
                p2.style.background = 'rgba(60, 60, 60, 0.8)';
            });
        }
    }
    function choosePlan(choice){
        if (!revLastBracket || !revLastTargetParam) return;
        revPlanChoice = choice;
        let N = parseFloat(revLotEl.value), n = parseFloat(revNEl.value), c = parseFloat(revCEl.value), aql = parseFloat(revAqlEl.value);
        const dist = revDistSel.value; let target = parseFloat(revTargetPaEl.value)/100;
        const sel = (choice==='upper'?revLastBracket.upper:revLastBracket.lower);
        if (!sel) return;
        if (revLastTargetParam==='N') N = sel.value;
        if (revLastTargetParam==='n') n = sel.value;
        if (revLastTargetParam==='c') c = sel.value;
        highlightSolvedInput(revLastTargetParam, N, n, c, aql, target);
        revLastPlan = { N:Math.round(N), n:Math.round(n), c:Math.round(c), aql:+aql, dist, targetPa: target };
        drawRevChart(revLastPlan.N, revLastPlan.n, revLastPlan.c, revLastPlan.aql, revLastPlan.dist);
        
        // Update visual indication of selected plan
        const p1 = document.getElementById('rev_plan1');
        const p2 = document.getElementById('rev_plan2');
        if (p1) {
            p1.style.border = choice === 'lower' ? '2px solid #1783FF' : '1px solid #424242';
            p1.style.background = choice === 'lower' ? 'rgba(45, 45, 45, 0.9)' : 'rgba(60, 60, 60, 0.8)';
        }
        if (p2) {
            p2.style.border = choice === 'upper' ? '2px solid #1783FF' : '1px solid #424242';
            p2.style.background = choice === 'upper' ? 'rgba(45, 45, 45, 0.9)' : 'rgba(60, 60, 60, 0.8)';
        }
    }
    function syncReverseDisabledInputs() {
        const target = revTargetParamSel?.value;
        if (!target) return;
        // enable all first
        [revLotEl, revNEl, revCEl, revAqlEl, revTargetPaEl].forEach(el=>{ if (el) { el.disabled = false; el.style.color = ''; } });
        // then disable the targeted one
        if (target==='N' && revLotEl) { revLotEl.disabled = true; revLotEl.value = ''; }
        else if (target==='n' && revNEl) { revNEl.disabled = true; revNEl.value = ''; }
        else if (target==='c' && revCEl) { revCEl.disabled = true; revCEl.value = ''; }
        else if (target==='aql' && revAqlEl) { revAqlEl.disabled = true; revAqlEl.value = ''; }
        else if (target==='targetPa' && revTargetPaEl) { revTargetPaEl.disabled = true; revTargetPaEl.value = ''; }
    }
    function highlightSolvedInput(targetParam, N, n, c, aql, targetPa) {
        // reset colors first
        [revLotEl, revNEl, revCEl, revAqlEl, revTargetPaEl].forEach(el=>{ if (el) el.style.color=''; });
        const solvedColor = '#f56c6c';
        if (targetParam==='N') { if (revLotEl){ revLotEl.value = String(Math.round(N)); revLotEl.style.color = solvedColor; } }
        else if (targetParam==='n') { if (revNEl){ revNEl.value = String(Math.round(n)); revNEl.style.color = solvedColor; } }
        else if (targetParam==='c') { if (revCEl){ revCEl.value = String(Math.round(c)); revCEl.style.color = solvedColor; } }
        else if (targetParam==='aql') { if (revAqlEl){ const txt = isFinite(aql)?(+aql).toFixed(aql<1?3:2):'-'; revAqlEl.value = txt; revAqlEl.style.color = solvedColor; } }
        else if (targetParam==='targetPa') { if (revTargetPaEl){ const paTxt = isFinite(targetPa)?(targetPa*100).toFixed(1):'-'; revTargetPaEl.value = paTxt; revTargetPaEl.style.color = solvedColor; } }
    }
    function clampInt(v, minV, maxV) { const x = Math.round(v); if (!isFinite(x)) return null; return Math.max(minV, Math.min(maxV, x)); }
    function solveForAql(targetPa, dist, N, n, c) {
        // binary search p in (0,1) so that CDF(c; N,n,p) ~= targetPa
        let lo=0, hi=1, mid; for (let i=0;i<50;i++){ mid=(lo+hi)/2; const pa = revComputePa(dist, N, n, c, mid); if (pa<targetPa) hi=mid; else lo=mid; }
        return mid*100; // percent
    }
    function solveForN(targetPa, dist, n, c, aqlPercent) {
        // search N from n (at least) up to an upper bound; choose nearest that matches target
        const p = aqlPercent/100; let bestN = n, bestErr = Infinity; for (let N=n; N<=100000; N = Math.max(N+1, Math.floor(N*1.2))) { const pa = revComputePa(dist, N, n, c, p); const err = Math.abs(pa-targetPa); if (err<bestErr){bestErr=err; bestN=N;} if (bestErr<1e-4 && N>n) break; } return bestN;
    }
    function solveForN_hyperLocal(targetPa, n, c, aqlPercent) { return solveForN(targetPa, 'hyper', n, c, aqlPercent); }
    function solveForN_generic(targetPa, dist, n, c, aqlPercent) { return solveForN(targetPa, dist, n, c, aqlPercent); }
    function solveForNWrapper(targetPa, dist, n, c, aqlPercent) { return (dist==='hyper')?solveForN_hyperLocal(targetPa, n, c, aqlPercent):solveForN_generic(targetPa, dist, n, c, aqlPercent); }
    function solveForN_poissonOrBinom(targetPa, dist, n, c, aqlPercent) { return solveForN_generic(targetPa, dist, n, c, aqlPercent); }
    function solveForNDispatch(targetPa, dist, n, c, aqlPercent) { return solveForNWrapper(targetPa, dist, n, c, aqlPercent); }
    function solveForC(targetPa, dist, N, n, aqlPercent) {
        const p = aqlPercent/100; let lower=null, upper=null;
        for (let c=0;c<=n;c++){
            const pa = revComputePa(dist, N, n, c, p);
            if (pa>=targetPa){ upper={value:c, pa}; lower = lower ?? { value: Math.max(0,c-1), pa: revComputePa(dist,N,n,Math.max(0,c-1),p)}; break; }
            lower = { value:c, pa };
        }
        return { lower, upper };
    }
    function solveForNFromTableIfC0(N, n, c) { return null; }
    function solveForNFromStandardIfNeeded(N, n, c) { return null; }
    function solveForNUsingHeuristic(targetPa, dist, n, c, aqlPercent) { return solveForNDispatch(targetPa, dist, n, c, aqlPercent); }
    function solveForNFinal(targetPa, dist, n, c, aqlPercent) { return solveForNUsingHeuristic(targetPa, dist, n, c, aqlPercent); }
    function solveForNBounded(targetPa, dist, n, c, aqlPercent) {
        // Only meaningful for hypergeometric; for others, the caller should block earlier
        const p = aqlPercent / 100;
        const Nmin = Math.max(1, Math.round(n));
        const paAtMin = revComputePa(dist, Nmin, n, c, p);
        let lower = null, upper = null;
        if (paAtMin >= targetPa) {
            // already meets target at minimal N; no true lower below n
            upper = { value: Nmin, pa: paAtMin };
            lower = null;
            return { lower, upper };
        }
        // Exponential expansion to find an upper bound where Pa >= targetPa
        let loN = Nmin, loPa = paAtMin;
        let hiN = Math.max(Nmin + 1, Math.floor(Nmin * 2));
        const MAX_N = 10000000;
        let hiPa = revComputePa(dist, hiN, n, c, p);
        while (hiPa < targetPa && hiN < MAX_N) {
            loN = hiN; loPa = hiPa;
            hiN = Math.min(MAX_N, Math.floor(hiN * 2));
            if (hiN <= loN) { hiN = loN + 1; }
            hiPa = revComputePa(dist, hiN, n, c, p);
        }
        if (hiPa < targetPa) {
            // Could not reach target even at MAX_N; return best-known lower only
            return { lower: { value: loN, pa: loPa }, upper: null };
        }
        // Bisection in [loN, hiN] to find smallest N with Pa >= targetPa
        let left = loN, right = hiN; let best = hiN, bestPa = hiPa;
        for (let i=0; i<60 && left <= right; i++) {
            const mid = Math.floor((left + right) / 2);
            const pa = revComputePa(dist, mid, n, c, p);
            if (pa >= targetPa) { best = mid; bestPa = pa; right = mid - 1; }
            else { left = mid + 1; }
        }
        lower = { value: loN, pa: loPa };
        upper = { value: best, pa: bestPa };
        return { lower, upper };
    }
    function solveForSampleSize(targetPa, dist, N, c, aqlPercent) {
        // Pa is monotonically DECREASING with n when c and p are fixed.
        const p = aqlPercent/100;
        const maxN = Math.max(1, Math.min(N || 200000, 200000));
        let lo = 1, hi = maxN;
        let paLo = revComputePa(dist, N, lo, c, p);
        let paHi = revComputePa(dist, N, hi, c, p);
        if (paLo <= targetPa) {
            // already below target at n=1 → no lower bound >= target
            return { lower: null, upper: { value: lo, pa: paLo } };
        }
        if (paHi >= targetPa) {
            // even at very large n still above target → no upper crossing
            return { lower: { value: hi, pa: paHi }, upper: null };
        }
        let lower = { value: lo, pa: paLo }; // Pa >= target
        let upper = { value: hi, pa: paHi };  // Pa < target
        // bisection to find boundary where Pa just drops below target
        while (lo + 1 < hi) {
            const mid = Math.floor((lo + hi) / 2);
            const pa = revComputePa(dist, N, mid, c, p);
            if (pa >= targetPa) {
                lo = mid; lower = { value: mid, pa };
            } else {
                hi = mid; upper = { value: mid, pa };
            }
        }
        return { lower, upper };
    }
    function solveForTargetPa(dist, N, n, c, aqlPercent) {
        const p = aqlPercent / 100;
        return revComputePa(dist, N, n, c, p) * 100; // return percent
    }
    function doReverseCalc(){
        revErrEl.style.display='none';
        const dist = revDistSel.value;
        const targetParam = revTargetParamSel.value;
        let target = parseFloat(revTargetPaEl.value)/100;
        if (targetParam!=='targetPa') {
            if (!(target>0 && target<1)) { revErrEl.textContent='Target Pa must be between 0 and 100.'; revErrEl.style.display='block'; return; }
        }
        let N = parseFloat(revLotEl.value), n = parseFloat(revNEl.value), c = parseFloat(revCEl.value), aql = parseFloat(revAqlEl.value);
        // strict validation: the four fixed inputs must be valid
        if (targetParam!=='N' && !(N>0)) { revErrEl.textContent='Invalid N.'; revErrEl.style.display='block'; return; }
        if (targetParam!=='n' && !(n>0)) { revErrEl.textContent='Invalid n.'; revErrEl.style.display='block'; return; }
        if (targetParam!=='c' && !(c>=0)) { revErrEl.textContent='Invalid c.'; revErrEl.style.display='block'; return; }
        if (targetParam!=='aql' && !(aql>0)) { revErrEl.textContent='Invalid AQL.'; revErrEl.style.display='block'; return; }
        if (dist!=='hyper') { if (targetParam==='N') { revErrEl.textContent='For Binomial/Poisson, N has no effect; cannot solve N.'; revErrEl.style.display='block'; return; } }
        let note='-'; let infoHidden=true; let infoText='';
        // Reset plan choice to default (upper) for each new calculation
        revPlanChoice = 'upper';
        if (targetParam==='aql') {
            const aqlPercent = solveForAql(target, dist, N, n, c); aql = aqlPercent;
        } else if (targetParam==='c') {
            const bracket = solveForC(target, dist, N, n, aql);
            revLastBracket = bracket; revLastTargetParam = 'c';
            const pick = (revPlanChoice==='lower'? bracket.lower : bracket.upper) || bracket.upper || bracket.lower;
            if (pick) c = pick.value; else c = 0;
            infoHidden=false; infoText = renderPlanLines(bracket.lower, bracket.upper, 'c', dist);
        } else if (targetParam==='n') {
            const bracket = solveForSampleSize(target, dist, N, c, aql);
            revLastBracket = bracket; revLastTargetParam = 'n';
            const pick = (revPlanChoice==='lower'? bracket.lower : bracket.upper) || bracket.upper || bracket.lower;
            if (pick) n = pick.value; else n = 1;
            infoHidden=false; infoText = renderPlanLines(bracket.lower, bracket.upper, 'n', dist);
        } else if (targetParam==='N') {
            const bracket = solveForNBounded(target, dist, n, c, aql);
            revLastBracket = bracket; revLastTargetParam = 'N';
            const pick = (revPlanChoice==='lower'? bracket.lower : bracket.upper) || bracket.upper || bracket.lower;
            if (pick) N = pick.value; else N = n;
            note='Solved N assumes hypergeometric model';
            infoHidden=false; infoText = renderPlanLines(bracket.lower, bracket.upper, 'N', dist);
        } else if (targetParam==='targetPa') {
            const t = solveForTargetPa(dist, N, n, c, aql); target = t / 100; note='Target Pa computed at AQL';
        }
        // write approximation info
        const infoEl = document.getElementById('rev_info'); if (infoEl){ infoEl.style.display = infoHidden?'none':'block'; infoEl.innerHTML = infoText; attachPlanChoiceHandlers(); }
        // write results into disabled input (highlight in red)
        highlightSolvedInput(targetParam, N, n, c, aql, target);
        revLastPlan = { N:Math.round(N), n:Math.round(n), c:Math.round(c), aql: +aql, dist, targetPa: target };
        drawRevChart(revLastPlan.N, revLastPlan.n, revLastPlan.c, revLastPlan.aql, revLastPlan.dist);
    }
    revCalcBtn?.addEventListener('click', doReverseCalc);
    revTargetParamSel?.addEventListener('change', syncReverseDisabledInputs);
    // initial disable sync
    syncReverseDisabledInputs();
    revClearBtn?.addEventListener('click', ()=>{
        revLotEl.value='500'; revNEl.value='125'; revCEl.value='1'; revAqlEl.value='1.0'; revTargetPaEl.value='95'; revDistSel.value='binom'; revTargetParamSel.value='aql'; revXMaxEl.value='5';
        if (revChart) { revChart.data.datasets=[]; revChart.update(); }
        [revLotEl, revNEl, revCEl, revAqlEl, revTargetPaEl].forEach(el=>{ if (el) { el.disabled=false; el.style.color=''; } });
        const infoEl = document.getElementById('rev_info'); if (infoEl){ infoEl.style.display='none'; infoEl.innerHTML=''; }
        syncReverseDisabledInputs();
        revLastPlan=null; revErrEl.style.display='none';
    });
    revXMaxEl?.addEventListener('input', ()=>{ if (revLastPlan) drawRevChart(revLastPlan.N, revLastPlan.n, revLastPlan.c, revLastPlan.aql, revLastPlan.dist); });
    document.getElementById('rev_export_png')?.addEventListener('click', ()=>{ if (!revChart) return; exportChartHiRes(revChart, 'reverse_oc_chart'); });
    document.getElementById('rev_export_csv')?.addEventListener('click', ()=>{ if (!revChart||!revLastPlan) return; let csv='x_defect_rate_percent,y_acceptance_prob,n,c,N,AQL,distribution,target_Pa\n'; revChart.data.datasets[0].data.forEach(p=>{ csv+=`${p.x},${p.y},${revLastPlan.n},${revLastPlan.c},${revLastPlan.N},${revLastPlan.aql},${revLastPlan.dist},${(revLastPlan.targetPa*100).toFixed(1)}%\n`; }); const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='reverse_oc_chart.csv'; a.click(); URL.revokeObjectURL(url); });
    // export plan to queue
    (function(){
        var btn = document.getElementById('rev_export_plan');
        if (!btn) return;
        btn.addEventListener('click', function(){
            if (!revLastPlan){ alert('No plan to export. Please calculate first.'); return; }
            window.planComparisonQueue = window.planComparisonQueue || [];
            var distName = revLastPlan.dist === 'hyper' ? 'Hypergeometric' : (revLastPlan.dist === 'binom' ? 'Binomial' : 'Poisson');
            var label = 'Reverse n='+revLastPlan.n+', c='+revLastPlan.c+' ('+distName+')';
            // Calculate efficiency data for consistent rating
            const aql = revLastPlan.aql;
            const paAql = calculateAcceptanceProbability(revLastPlan.n, revLastPlan.c, aql / 100, revLastPlan.N, revLastPlan.dist);
            const ltpd = aql * 2; // Assume LTPD is 2x AQL for reverse plans
            const paLtpd = calculateAcceptanceProbability(revLastPlan.n, revLastPlan.c, ltpd / 100, revLastPlan.N, revLastPlan.dist);
            const actualAlpha = 1 - paAql;
            const actualBeta = paLtpd;
            
            window.planComparisonQueue.push({ 
                n: revLastPlan.n, 
                c: revLastPlan.c, 
                aql: aql, 
                label: label,
                dist: revLastPlan.dist,
                N: revLastPlan.N,
                source: 'reverse',
                // Include efficiency calculation data
                paAql: paAql,
                paLtpd: paLtpd,
                actualAlpha: actualAlpha,
                actualBeta: actualBeta
            });
            alert('Exported to Plan Comparison queue. Switch to Multiple Plan Comparison to import.');
        });
    })();

    // ===== C=0 page functionality =====
    const c0LotEl = document.getElementById('c0_lot_size');
    const c0AqlSel = document.getElementById('c0_aql');
    const c0AqlCustomEl = document.getElementById('c0_aql_custom');
    const c0DistSel = document.getElementById('c0_dist_select');
    const c0LookupBtn = document.getElementById('c0_lookup_btn');
    const c0ClearBtn = document.getElementById('c0_clear_btn');
    const c0ErrEl = document.getElementById('c0_error');
    const c0XMaxEl = document.getElementById('c0_x_max');
    const c0Canvas = document.getElementById('ocChartC0');
    const c0Ctx = c0Canvas?.getContext('2d');
    let c0Chart = null;
    let c0LastPlan = null; // {N,n,c=0,aql,dist}

    function formatAqlLabel(v) { return (+v).toFixed(v < 1 ? 3 : 1); }

    function buildC0AqlOptions() {
        if (!c0AqlSel) return;
        const keysSet = new Set();
        if (typeof C0_SAMPLING_TABLE !== 'undefined') {
            C0_SAMPLING_TABLE.forEach(row => {
                Object.keys(row.samples).forEach(k => keysSet.add(k));
            });
        }
        // preserve original string keys but sort numerically
        const keys = Array.from(keysSet).filter(k => k !== 'null');
        keys.sort((a,b)=>parseFloat(a)-parseFloat(b));
        c0AqlSel.innerHTML = '';
        keys.forEach(k => {
            const num = parseFloat(k);
            const opt = document.createElement('option');
            opt.value = k; // keep exact key like '1.0'
            opt.textContent = isNaN(num) ? k : formatAqlLabel(num);
            c0AqlSel.appendChild(opt);
        });
        const custom = document.createElement('option');
        custom.value = 'custom';
        custom.textContent = 'Custom';
        c0AqlSel.appendChild(custom);
        // Prefer a 0.4 numeric default if present; fall back to 1.0 or first
        const desiredNumC0 = 0.4;
        let desiredKeyC0 = keys.find(k => Math.abs(parseFloat(k) - desiredNumC0) < 1e-9);
        if (!desiredKeyC0) desiredKeyC0 = keys.includes('1.0') ? '1.0' : (keys[0] ?? 'custom');
        c0AqlSel.value = desiredKeyC0;
        c0AqlCustomEl.disabled = c0AqlSel.value !== 'custom';
    }

    function ensureC0Chart() {
        if (c0Chart) return c0Chart;
        
        // Crosshair plugin for C=0 page
        const c0CrosshairPlugin = {
            id: 'c0CrosshairPlugin',
            afterEvent: function(chart, args){
                const e = args.event; if (!e) return;
                chart._crosshair = chart._crosshair || { x: null, y: null };
                if (e.type==='mousemove'){ chart._crosshair.x = e.x; chart._crosshair.y = e.y; chart.draw(); }
                if (e.type==='mouseout'){ chart._crosshair.x = null; chart._crosshair.y = null; chart.draw(); }
            },
            afterDraw: function(chart){
                const cx = chart._crosshair && chart._crosshair.x; const cy = chart._crosshair && chart._crosshair.y;
                if (cx==null || cy==null) return;
                const ctx = chart.ctx; const area = chart.chartArea; if (!area) return;
                ctx.save();
                ctx.strokeStyle = 'rgba(199,202,207,0.5)';
                ctx.setLineDash([4,4]);
                // vertical line
                ctx.beginPath(); ctx.moveTo(cx, area.top); ctx.lineTo(cx, area.bottom); ctx.stroke();
                // horizontal line
                ctx.beginPath(); ctx.moveTo(area.left, cy); ctx.lineTo(area.right, cy); ctx.stroke();
                // read scale values
                const xScaleRef = chart.scales && chart.scales.x; const yScaleRef = chart.scales && chart.scales.y;
                if (xScaleRef && yScaleRef){
                    const xVal = xScaleRef.getValueForPixel(cx);
                    const yVal = yScaleRef.getValueForPixel(cy);
                    if (isFinite(xVal) && isFinite(yVal)){
                        const xTxt = xVal.toFixed(2) + '%';
                        const yTxt = (yVal*100).toFixed(1) + '%';
                        const label = 'p=' + xTxt + ' , Pa=' + yTxt;
                        ctx.fillStyle = 'rgba(28,42,54,0.9)'; ctx.strokeStyle='rgba(64,84,102,0.9)';
                        ctx.setLineDash([]);
                        const pad = 6; ctx.font = '12px sans-serif';
                        const w = ctx.measureText(label).width + pad*2; const h = 20;
                        const bx = Math.min(Math.max(area.left, cx+8), area.right - w);
                        const by = Math.max(area.top, cy - h - 8);
                        ctx.beginPath(); ctx.roundRect ? ctx.roundRect(bx, by, w, h, 6) : ctx.rect(bx, by, w, h);
                        ctx.fill(); ctx.stroke();
                        ctx.fillStyle = '#e6e9ee'; ctx.fillText(label, bx+pad, by+14);
                    }
                }
                ctx.restore();
            }
        };
        
        c0Chart = new Chart(c0Ctx, {
            type: 'line', data: { datasets: [] }, options: {
                responsive: true, maintainAspectRatio: false, animation: false,
                plugins: { 
                    legend: { display: true, labels: { color: getThemeColors().text } },
                    tooltip: {
                        enabled: true,
                        callbacks: {
                            label: function(context) {
                                const x = context.parsed && context.parsed.x;
                                const y = context.parsed && context.parsed.y;
                                const datasetLabel = context.dataset.label || '';
                                const xText = (isFinite(x) ? (+x).toFixed(x < 1 ? 3 : 2) : '-');
                                const yText = (isFinite(y) ? (y * 100).toFixed(1) : '-');
                                return `${datasetLabel}: p=${xText}%, Pa=${yText}%`;
                            }
                        }
                    }
                },
                scales: {
                    x: { type: 'linear', title: { display: true, text: 'Defect Rate (p%)', color: getThemeColors().text }, grid: { color: getThemeColors().grid }, ticks: { color: getThemeColors().text } },
                    y: { min: 0, max: 1, title: { display: true, text: 'Acceptance Probability (Pa%)', color: getThemeColors().text }, ticks: { callback: function(v){ return (v*100).toFixed(0)+'%'; }, color: getThemeColors().text }, grid: { color: getThemeColors().grid } }
                }
            },
            plugins: [c0CrosshairPlugin]
        });
        return c0Chart;
    }

    function generatePValuesC0(maxXPercent) {
        const step = 0.05; const num = Math.floor(maxXPercent / step) + 1;
        return Array.from({ length: num }, (_, i) => +(i * step).toFixed(2));
    }

    function computePa(dist, N, n, c, p) {
        let result;
        if (dist === 'binom') result = jStat.binomial.cdf(c, n, p);
        else if (dist === 'pois') result = jStat.poisson.cdf(c, n * p);
        else {
            // hyper
            const m = Math.round(N * p);
            result = jStat.hypgeom.cdf(c, N, m, n);
        }
        return validateAcceptanceProbability(result, `computePa(dist=${dist}, N=${N}, n=${n}, c=${c}, p=${p})`);
    }

    function findLTPD10(dist, N, n) {
        // find p where Pa = 0.10 for c=0
        const target = 0.10; const c = 0;
        // simple binary search on p in [0, 1]
        let lo = 0, hi = 1, mid;
        for (let i=0;i<40;i++) {
            mid = (lo+hi)/2;
            const pa = computePa(dist, N, n, c, mid);
            if (pa > target) lo = mid; else hi = mid;
        }
        return mid * 100; // percent
    }

    function updateC0Chart() {
        if (!c0LastPlan) return;
        const { N, n, aql, dist } = c0LastPlan;
        const maxX = parseFloat(c0XMaxEl.value || '5');
        const xs = generatePValuesC0(maxX);
        ensureC0Chart();
        c0Chart.options.scales.x.max = maxX;
        const data = xs.map(px => ({ x: px, y: computePa(dist, N, n, 0, px/100) }));
        c0Chart.data.datasets = [{ label: `C=0 Plan (n=${n}, c=0, AQL=${formatAqlLabel(aql)}, N=${N})`, data, borderColor: 'rgba(46,204,113,1)', backgroundColor: 'rgba(46,204,113,0.25)', borderWidth: 2, pointRadius: 0, tension: 0.1 }];
        c0Chart.update();
    }

    function findC0SampleSizeFromTable(N, aqlSelValue) {
        if (typeof C0_SAMPLING_TABLE === 'undefined') return null;
        const aqlStr = String(aqlSelValue);
        const aqlNum = parseFloat(aqlSelValue);
        for (let i=0;i<C0_SAMPLING_TABLE.length;i++) {
            const entry = C0_SAMPLING_TABLE[i];
            const min = entry.lot_range[0]; const max = entry.lot_range[1];
            if (N >= min && (max === Infinity || N <= max)) {
                if (Object.prototype.hasOwnProperty.call(entry.samples, aqlStr)) return entry.samples[aqlStr];
                // numeric-normalized match (e.g., '0.40' vs '0.4')
                const keys = Object.keys(entry.samples);
                for (const k of keys) {
                    if (!isNaN(aqlNum) && Math.abs(parseFloat(k) - aqlNum) < 1e-9) return entry.samples[k];
                }
                return null;
            }
        }
        return null;
    }
    function doC0Lookup() {
        c0ErrEl.style.display = 'none';
        const N = parseFloat(c0LotEl.value);
        // Robust validation: accept any positive number; if helper exists, also require it
        const basicValid = (N > 0 && isFinite(N));
        const helperValid = (typeof window.isC0LotSizeValid === 'function') ? isC0LotSizeValid(N) : true;
        if (!(basicValid && helperValid)) { c0ErrEl.textContent = 'Invalid lot size.'; c0ErrEl.style.display = 'block'; return; }
        let aqlDisplay, aqlForLookup;
        if (c0AqlSel.value === 'custom') {
            const aqlNum = parseFloat(c0AqlCustomEl.value);
            if (!(aqlNum > 0)) { c0ErrEl.textContent = 'Custom AQL must be > 0.'; c0ErrEl.style.display = 'block'; return; }
            aqlDisplay = formatAqlLabel(aqlNum) + '%';
            aqlForLookup = aqlNum; // numeric triggers fallback formula in helper
        } else {
            aqlForLookup = c0AqlSel.value; // preserve exact key string like '1.0'
            aqlDisplay = c0AqlSel.options[c0AqlSel.selectedIndex]?.textContent || `${aqlForLookup}%`;
        }
        // Prefer exact table lookup with tolerant key matching; fallback to helper's formula only if not found.
        let n = findC0SampleSizeFromTable(N, aqlForLookup);
        if (!(n > 0)) {
            n = (typeof window.lookupC0SampleSize === 'function') ? lookupC0SampleSize(N, aqlForLookup) : Math.max(1, Math.round(N * (parseFloat(aqlForLookup) || 0) / 100));
        }
        if (!(n > 0)) { c0ErrEl.textContent = 'No valid sample size found.'; c0ErrEl.style.display = 'block'; return; }
        const dist = c0DistSel.value;

        // results
        document.getElementById('c0_result_n').value = String(n);
        document.getElementById('c0_result_c').value = '0';
        document.getElementById('c0_result_aql').value = aqlDisplay;
        // lot range display
        let rangeText = '-';
        if (typeof C0_SAMPLING_TABLE !== 'undefined') {
            for (const entry of C0_SAMPLING_TABLE) {
                const [min, max] = entry.lot_range;
                if (N >= min && (max === Infinity || N <= max)) { rangeText = `${min} - ${max === Infinity ? '∞' : max}`; break; }
            }
        }
        document.getElementById('c0_result_lot_range').value = rangeText;
        const ltpD10 = findLTPD10(dist, N, n);
        document.getElementById('c0_result_lq10').value = ltpD10.toFixed(2) + ' %';

        const aqlNumForPlan = (typeof aqlForLookup === 'string') ? parseFloat(aqlForLookup) : aqlForLookup;
        c0LastPlan = { N, n, aql: aqlNumForPlan, dist };
        updateC0Chart();
    }

    // Events
    c0AqlSel?.addEventListener('change', () => {
        c0AqlCustomEl.disabled = c0AqlSel.value !== 'custom';
    });
    c0LookupBtn?.addEventListener('click', doC0Lookup);
    c0ClearBtn?.addEventListener('click', () => {
        c0LotEl.value = '500'; c0XMaxEl.value = '5'; buildC0AqlOptions(); c0AqlCustomEl.value = '1.0'; c0DistSel.value = 'binom';
        document.getElementById('c0_result_n').value = '-';
        document.getElementById('c0_result_c').value = '0';
        document.getElementById('c0_result_aql').value = '-';
        document.getElementById('c0_result_lot_range').value = '-';
        document.getElementById('c0_result_lq10').value = '-';
        if (c0Chart) { c0Chart.data.datasets = []; c0Chart.update(); }
        c0LastPlan = null; c0ErrEl.style.display = 'none';
    });
    c0XMaxEl?.addEventListener('input', updateC0Chart);

    // Exports
    function exportC0Png() { if (!c0Chart) return; exportChartHiRes(c0Chart, 'c0_oc_chart'); }
    function exportC0Csv() {
        if (!c0Chart || !c0LastPlan) return; let csv = 'x_defect_rate_percent,y_acceptance_prob,n,c,N,AQL,distribution\n';
        c0Chart.data.datasets[0].data.forEach(p => { csv += `${p.x},${p.y},${c0LastPlan.n},0,${c0LastPlan.N},${formatAqlLabel(c0LastPlan.aql)},${c0LastPlan.dist}\n`; });
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'c0_oc_chart.csv'; a.click(); URL.revokeObjectURL(url);
    }
    document.getElementById('c0_export_png_toolbar')?.addEventListener('click', exportC0Png);
    document.getElementById('c0_export_csv_toolbar')?.addEventListener('click', exportC0Csv);
    // export plan to queue
    (function(){
        var btn=document.getElementById('c0_export_plan');
        if (!btn) return;
        btn.addEventListener('click', function(){
            if (!c0LastPlan){ alert('No plan to export. Please lookup first.'); return; }
            window.planComparisonQueue = window.planComparisonQueue || [];
            var distName = c0LastPlan.dist === 'hyper' ? 'Hypergeometric' : (c0LastPlan.dist === 'binom' ? 'Binomial' : 'Poisson');
            var label = 'C=0 n='+c0LastPlan.n+' @AQL='+formatAqlLabel(c0LastPlan.aql)+'% ('+distName+')';
            // Calculate efficiency data for consistent rating
            const aql = c0LastPlan.aql;
            const paAql = calculateAcceptanceProbability(c0LastPlan.n, 0, aql / 100, c0LastPlan.N, c0LastPlan.dist);
            const ltpd = aql * 2; // Assume LTPD is 2x AQL for C=0 plans
            const paLtpd = calculateAcceptanceProbability(c0LastPlan.n, 0, ltpd / 100, c0LastPlan.N, c0LastPlan.dist);
            const actualAlpha = 1 - paAql;
            const actualBeta = paLtpd;
            
            window.planComparisonQueue.push({ 
                n: c0LastPlan.n, 
                c: 0, 
                aql: aql, 
                label: label,
                dist: c0LastPlan.dist,
                N: c0LastPlan.N,
                source: 'c0',
                // Include efficiency calculation data
                paAql: paAql,
                paLtpd: paLtpd,
                actualAlpha: actualAlpha,
                actualBeta: actualBeta
            });
            alert('Exported to Plan Comparison queue. Switch to Multiple Plan Comparison to import.');
        });
    })();

    // Populate AQL options initially
    buildC0AqlOptions();

    // ===== AQL page functionality =====
    const ssLotEl = document.getElementById('ss_lot_size');
    const ssLevelSel = document.getElementById('ss_inspection_level');
    const ssAqlSel = document.getElementById('ss_aql');
    const ssAqlCustomEl = document.getElementById('ss_aql_custom');
    const ssDistSel = document.getElementById('ss_dist_select');
    const ssStateSel = document.getElementById('ss_state_select');
    const ssLookupBtn = document.getElementById('ss_lookup_btn');
    const ssClearBtn = document.getElementById('ss_clear_btn');
    const ssErrEl = document.getElementById('ss_error');
    const ssXMaxEl = document.getElementById('ss_x_max');
    const ssCtx = document.getElementById('ocChartAQL')?.getContext('2d');
    let ssChart = null; let ssLastPlan = null; // {N, level, code, n, c, aql, dist}
    let ssAllAqlKeys = null; // collected from master tables

    function populateInspectionLevels() {
        if (!ssLevelSel) return;
        const levels = ['I','II','III','S-1','S-2','S-3','S-4'];
        ssLevelSel.innerHTML = '';
        levels.forEach(l => { const o = document.createElement('option'); o.value = l; o.textContent = l; ssLevelSel.appendChild(o); });
        ssLevelSel.value = 'II';
    }
    function collectAqlKeys() {
        const sets = [];
        const pushKeys = (tbl) => {
            if (!tbl) return;
            Object.keys(tbl).forEach(letter => {
                const row = tbl[letter];
                if (!row) return;
                Object.keys(row).forEach(k => sets.push(k));
            });
        };
        pushKeys(typeof normal_rawMasterTableData!=='undefined' ? normal_rawMasterTableData : null);
        pushKeys(typeof tightened_rawMasterTableData!=='undefined' ? tightened_rawMasterTableData : null);
        pushKeys(typeof reduced_rawMasterTableData!=='undefined' ? reduced_rawMasterTableData : null);
        // unique & numeric-sort by value
        const uniq = Array.from(new Set(sets));
        uniq.sort((a,b)=>parseFloat(a)-parseFloat(b));
        return uniq;
    }
    function populateAqlLevels() {
        if (!ssAqlSel) return;
        if (!ssAllAqlKeys) ssAllAqlKeys = collectAqlKeys();
        const keys = ssAllAqlKeys && ssAllAqlKeys.length ? ssAllAqlKeys.slice() : ['0.15','0.40','0.65','1.0','2.5'];
        ssAqlSel.innerHTML='';
        keys.forEach(k => { const o=document.createElement('option'); o.value=k; o.textContent=k; ssAqlSel.appendChild(o); });
        const custom = document.createElement('option'); custom.value='custom'; custom.textContent='Custom'; ssAqlSel.appendChild(custom);
        const desiredAttr = ssAqlSel.getAttribute('data-default') || '0.4';
        const desiredNum = parseFloat(desiredAttr);
        let desiredKey = keys.find(k => Math.abs(parseFloat(k) - desiredNum) < 1e-9);
        if (!desiredKey) desiredKey = keys.includes('1.0') ? '1.0' : (keys[0] || 'custom');
        ssAqlSel.value = desiredKey;
        ssAqlCustomEl.disabled = ssAqlSel.value !== 'custom';
    }
    function ensureSsChart() {
        if (ssChart) return ssChart;
        
        // Crosshair plugin for AQL Lookup page
        const ssCrosshairPlugin = {
            id: 'ssCrosshairPlugin',
            afterEvent: function(chart, args){
                const e = args.event; if (!e) return;
                chart._crosshair = chart._crosshair || { x: null, y: null };
                if (e.type==='mousemove'){ chart._crosshair.x = e.x; chart._crosshair.y = e.y; chart.draw(); }
                if (e.type==='mouseout'){ chart._crosshair.x = null; chart._crosshair.y = null; chart.draw(); }
            },
            afterDraw: function(chart){
                const cx = chart._crosshair && chart._crosshair.x; const cy = chart._crosshair && chart._crosshair.y;
                if (cx==null || cy==null) return;
                const ctx = chart.ctx; const area = chart.chartArea; if (!area) return;
                ctx.save();
                ctx.strokeStyle = 'rgba(199,202,207,0.5)';
                ctx.setLineDash([4,4]);
                // vertical line
                ctx.beginPath(); ctx.moveTo(cx, area.top); ctx.lineTo(cx, area.bottom); ctx.stroke();
                // horizontal line
                ctx.beginPath(); ctx.moveTo(area.left, cy); ctx.lineTo(area.right, cy); ctx.stroke();
                // read scale values
                const xScaleRef = chart.scales && chart.scales.x; const yScaleRef = chart.scales && chart.scales.y;
                if (xScaleRef && yScaleRef){
                    const xVal = xScaleRef.getValueForPixel(cx);
                    const yVal = yScaleRef.getValueForPixel(cy);
                    if (isFinite(xVal) && isFinite(yVal)){
                        const xTxt = xVal.toFixed(2) + '%';
                        const yTxt = (yVal*100).toFixed(1) + '%';
                        const label = 'p=' + xTxt + ' , Pa=' + yTxt;
                        ctx.fillStyle = 'rgba(28,42,54,0.9)'; ctx.strokeStyle='rgba(64,84,102,0.9)';
                        ctx.setLineDash([]);
                        const pad = 6; ctx.font = '12px sans-serif';
                        const w = ctx.measureText(label).width + pad*2; const h = 20;
                        const bx = Math.min(Math.max(area.left, cx+8), area.right - w);
                        const by = Math.max(area.top, cy - h - 8);
                        ctx.beginPath(); ctx.roundRect ? ctx.roundRect(bx, by, w, h, 6) : ctx.rect(bx, by, w, h);
                        ctx.fill(); ctx.stroke();
                        ctx.fillStyle = '#e6e9ee'; ctx.fillText(label, bx+pad, by+14);
                    }
                }
                ctx.restore();
            }
        };
        
        ssChart = new Chart(ssCtx, { type:'line', data:{datasets:[]}, options:{ responsive:true, maintainAspectRatio:false, animation:false,
            plugins:{ 
                legend:{ display:true, labels:{ color: getThemeColors().text } },
                tooltip: {
                    enabled: true,
                    callbacks: {
                        label: function(context) {
                            const x = context.parsed && context.parsed.x;
                            const y = context.parsed && context.parsed.y;
                            const datasetLabel = context.dataset.label || '';
                            const xText = (isFinite(x) ? (+x).toFixed(x < 1 ? 3 : 2) : '-');
                            const yText = (isFinite(y) ? (y * 100).toFixed(1) : '-');
                            return `${datasetLabel}: p=${xText}%, Pa=${yText}%`;
                        }
                    }
                }
            },
                scales:{ x:{ type:'linear', title:{ display:true, text:'Defect Rate (p%)', color: getThemeColors().text }, grid:{ color: getThemeColors().grid }, ticks:{ color: getThemeColors().text } },
                    y:{ min:0, max:1, title:{ display:true, text:'Acceptance Probability (Pa%)', color: getThemeColors().text }, ticks:{ callback:function(v){ return (v*100).toFixed(0)+'%'; }, color: getThemeColors().text }, grid:{ color: getThemeColors().grid } } }
        }, plugins: [ssCrosshairPlugin]});
        return ssChart;
    }
    function getCodeLetter(N, level) {
        if (typeof codeLetterTable === 'undefined') return null;
        for (const row of codeLetterTable) {
            const max = (row.max==null?Infinity:row.max);
            if (N >= row.min && N <= max) return row.levels[level];
        }
        return null;
    }
    function getStateRefs() {
        const state = ssStateSel?.value || 'normal';
        if (state==='tightened') {
            return { table: typeof tightened_rawMasterTableData!=='undefined'?tightened_rawMasterTableData:null,
                     sizes: typeof tightened_sampleSizes!=='undefined'?tightened_sampleSizes:null,
                     order: typeof codeLettersOrder_tightened!=='undefined'?codeLettersOrder_tightened:null,
                     label: 'Tightened' };
        }
        if (state==='reduced') {
            return { table: typeof reduced_rawMasterTableData!=='undefined'?reduced_rawMasterTableData:null,
                     sizes: typeof reduced_sampleSizes!=='undefined'?reduced_sampleSizes:null,
                     order: typeof codeLettersOrder_reduced!=='undefined'?codeLettersOrder_reduced:null,
                     label: 'Reduced' };
        }
        return { table: typeof normal_rawMasterTableData!=='undefined'?normal_rawMasterTableData:(typeof rawMasterTableData!=='undefined'?rawMasterTableData:null),
                 sizes: typeof normal_sampleSizes!=='undefined'?normal_sampleSizes:(typeof sampleSizes!=='undefined'?sampleSizes:null),
                 order: typeof codeLettersOrder_normal!=='undefined'?codeLettersOrder_normal:null,
                 label: 'Normal' };
    }
    function getSampleSizeFromCode(code) { const r=getStateRefs(); return r.sizes?.[code] || null; }
    function getValueByNumericAqlKey(rowObj, aqlStr){
        if (!rowObj) return undefined;
        if (aqlStr in rowObj) return rowObj[aqlStr];
        const target = parseFloat(aqlStr);
        if (!isFinite(target)) return undefined;
        // tolerant numeric equivalence match (handles '0.4' vs '0.40' etc.)
        let bestKey; let bestDelta = Infinity;
        for (const k in rowObj){
            const v = parseFloat(k);
            if (!isFinite(v)) continue;
            const d = Math.abs(v - target);
            if (d < bestDelta){ bestDelta = d; bestKey = k; }
        }
        // exact numeric equality within tiny epsilon
        if (bestKey!=null && Math.abs(parseFloat(bestKey) - target) < 1e-12) return rowObj[bestKey];
        // also accept near-equality for common rounding mismatches
        if (bestKey!=null && Math.abs(parseFloat(bestKey) - target) < 1e-6) return rowObj[bestKey];
        return undefined;
    }
    function normalizeAcReCell(cell, isReduced){
        if (cell==null) return null;
        if (typeof cell==='number') {
            if (isReduced && cell===0) return { ac: 0, re: 1 }; // per reduced table common rule
            return { ac: cell, re: cell+1 };
        }
        if (Array.isArray(cell) && cell.length===2 && cell.every(n=>typeof n==='number')) {
            return { ac: cell[0], re: cell[1] };
        }
        if (typeof cell==='object' && typeof cell.ac==='number' && typeof cell.re==='number') return { ac: cell.ac, re: cell.re };
        return null;
    }
    function findFinalPlan(initialLetter, aqlStr) {
        const refs = getStateRefs();
        if (!refs.table || !refs.order) return { finalLetter: null, finalAc: null };
        let currentIndex = refs.order.indexOf(initialLetter);
        if (currentIndex === -1) return { finalLetter: null, finalAc: null };
        let currentLetter = initialLetter;
        let plan = getValueByNumericAqlKey(refs.table[currentLetter], aqlStr);
        const visited = new Set([currentLetter]);
        while (plan === 'down' || plan === 'up') {
            currentIndex += (plan === 'down' ? 1 : -1);
            if (currentIndex < 0 || currentIndex >= refs.order.length) return { finalLetter: null, finalAc: null };
            currentLetter = refs.order[currentIndex];
            if (visited.has(currentLetter)) return { finalLetter: null, finalAc: null };
            visited.add(currentLetter);
            plan = getValueByNumericAqlKey(refs.table[currentLetter], aqlStr);
        }
        // allow number or {ac,re}
        const norm = normalizeAcReCell(plan, (ssStateSel?.value==='reduced'));
        if (!norm) return { finalLetter: null, finalAc: null };
        return { finalLetter: currentLetter, finalAc: norm.ac, finalRe: norm.re };
    }
    function ssComputePa(dist, N, n, c, p) {
        let result;
        if (dist==='binom') result = jStat.binomial.cdf(c, n, p);
        else if (dist==='pois') result = jStat.poisson.cdf(c, n*p);
        else {
            const m = Math.round(N*p); 
            result = jStat.hypgeom.cdf(c, N, m, n);
        }
        return validateAcceptanceProbability(result, `ssComputePa(dist=${dist}, N=${N}, n=${n}, c=${c}, p=${p})`);
    }
    function drawSsChart(N, n, c, aql, code, level, dist) {
        const maxX = parseFloat(ssXMaxEl.value||'5'); const xs = generatePValuesC0(maxX);
        ensureSsChart(); ssChart.options.scales.x.max = maxX;
        // Pa = P[X <= c], Pr = P[X >= re], Pc band between Pa and (1-Pr)
        const acceptColor = 'rgba(241,196,15,1)';
        const rejectColor = 'rgba(231,76,60,1)';
        const continueFill = 'rgba(52,152,219,0.20)';
        const paData = []; const prData = []; const upperData = [];
        const re = (typeof ssLastPlan?.re==='number') ? ssLastPlan.re : (c!=null?c+1:null);
        for (let i=0;i<xs.length;i++){
            const px = xs[i]; const p = px/100;
            const Pa = ssComputePa(dist, N, n, c, p);
            let Pr;
            if (re!=null && re>c) {
                const cdfReMinus1 = ssComputePa(dist, N, n, re-1, p);
                Pr = Math.max(0, 1 - cdfReMinus1);
            } else {
                Pr = Math.max(0, 1 - Pa);
            }
            paData.push({x:px,y:Pa});
            prData.push({x:px,y:Pr});
            upperData.push({x:px,y:Math.max(0, 1 - Pr)}); // Pa + Pc
        }
        ssChart.data.datasets = [
            { label:`Accept (Pa)  n=${n}, c=${c}, AQL=${aql}, Code=${code}, Level=${level}`, data:paData, borderColor:acceptColor, backgroundColor:'transparent', borderWidth:2, pointRadius:0, tension:0.1 },
            { label:'Continue (Pc)', data:upperData, borderColor:'rgba(0,0,0,0)', backgroundColor:continueFill, fill:'-1', pointRadius:0, tension:0.1 },
            { label:'Reject (Pr)', data:prData, borderColor:rejectColor, backgroundColor:'transparent', borderDash:[6,4], borderWidth:2, pointRadius:0, tension:0.1 }
        ];
        ssChart.update();
    }
    function doSsLookup() {
        ssErrEl.style.display='none';
        const N = parseFloat(ssLotEl.value); if (!(N>0)) { ssErrEl.textContent='Invalid lot size.'; ssErrEl.style.display='block'; return; }
        const level = ssLevelSel.value;
        let aqlStr; if (ssAqlSel.value==='custom') { const aqlNum = parseFloat(ssAqlCustomEl.value); if (!(aqlNum>0)) { ssErrEl.textContent='Custom AQL must be > 0.'; ssErrEl.style.display='block'; return; } aqlStr = aqlNum.toString(); } else { aqlStr = ssAqlSel.value; }
        const code0 = getCodeLetter(N, level); if (!code0) { ssErrEl.textContent='No code letter for inputs.'; ssErrEl.style.display='block'; return; }
        const finalPlan = findFinalPlan(code0, aqlStr);
        if (!finalPlan.finalLetter || typeof finalPlan.finalAc !== 'number') { ssErrEl.textContent='No numeric acceptance number found for this AQL in the selected state.'; ssErrEl.style.display='block'; if (ssChart) { ssChart.data.datasets=[]; ssChart.update(); } return; }
        const code = finalPlan.finalLetter; const c = finalPlan.finalAc; const re = (typeof finalPlan.finalRe==='number'?finalPlan.finalRe:(c!=null?c+1:null));
        const n = getSampleSizeFromCode(code); if (!n) { ssErrEl.textContent='No sample size for code letter in this state.'; ssErrEl.style.display='block'; return; }
        let note='-'; if (code !== code0) note = `Resolved by ${code0} → ${code}`;

        // write results
        document.getElementById('ss_result_code').value = code;
        document.getElementById('ss_result_n').value = String(n);
        document.getElementById('ss_result_c').value = (c==null?'-':String(c));
        const reEl = document.getElementById('ss_result_re'); if (reEl) reEl.value = (re==null?'-':String(re));
        const stateLabel = ssStateSel.value.charAt(0).toUpperCase()+ssStateSel.value.slice(1);
        document.getElementById('ss_result_state').value = stateLabel;
        document.getElementById('ss_result_note').value = note;

        const dist = ssDistSel.value;
        // compute tri-state at AQL for reduced
        const p = parseFloat(aqlStr)/100;
        const Pa = ssComputePa(dist, N, n, c, p);
        let Pr = 0, Pc = 0;
        if (ssStateSel.value==='reduced' && re!=null && re>c) {
            // P(reject) = P[X >= Re] = 1 - P[X <= Re-1]
            const cdfReMinus1 = ssComputePa(dist, N, n, re-1, p);
            Pr = Math.max(0, 1 - cdfReMinus1);
            Pc = Math.max(0, 1 - Pa - Pr);
        } else {
            // For normal and tightened inspection, only accept/reject
            // P(reject) = 1 - P(accept)
            Pr = Math.max(0, 1 - Pa);
            Pc = 0; // No continue state for normal/tightened
        }
        const paEl = document.getElementById('ss_result_pa'); if (paEl) paEl.value = (Pa*100).toFixed(2)+'%';
        const prEl = document.getElementById('ss_result_prej'); if (prEl) prEl.value = (Pr*100).toFixed(2)+'%';
        const pcEl = document.getElementById('ss_result_pcont'); if (pcEl) pcEl.value = (Pc*100).toFixed(2)+'%';
        
        // Check if n >= N (全檢的情況)
        if (n >= N) {
            ssErrEl.textContent = `Sample size n=${n} >= Lot size N=${N}. Consider 100% inspection instead of sampling.`;
            ssErrEl.style.display = 'block';
            
            // Still save the plan data but don't draw chart
            ssLastPlan = { N, level, code, n, c, aql: aqlStr, dist };
            if (ssChart) { ssChart.data.datasets = []; ssChart.update(); }
            return;
        }
        
        ssLastPlan = { N, level, code, n, c, re, aql: aqlStr, dist };
        if (c==null) { if (ssChart) { ssChart.data.datasets=[]; ssChart.update(); } return; }
        drawSsChart(N, n, c, aqlStr, code, level, dist);
    }
    ssAqlSel?.addEventListener('change', ()=>{ ssAqlCustomEl.disabled = ssAqlSel.value!=='custom'; });
    ssLookupBtn?.addEventListener('click', doSsLookup);
    ssClearBtn?.addEventListener('click', ()=>{
        ssLotEl.value='500'; populateInspectionLevels(); populateAqlLevels(); ssAqlCustomEl.value='1.0'; ssDistSel.value='binom'; ssStateSel.value='normal';
        ['ss_result_code','ss_result_n','ss_result_c','ss_result_state','ss_result_note'].forEach(id=>{ const el=document.getElementById(id); if (el) el.value = id==='ss_result_state'?'Normal':'-'; });
        if (ssChart) { ssChart.data.datasets=[]; ssChart.update(); }
        ssLastPlan=null; ssErrEl.style.display='none';
    });
    ssXMaxEl?.addEventListener('input', ()=>{ if (ssLastPlan && ssLastPlan.c!=null) drawSsChart(ssLastPlan.N, ssLastPlan.n, ssLastPlan.c, ssLastPlan.aql, ssLastPlan.code, ssLastPlan.level, ssLastPlan.dist); });
    // Exports
    document.getElementById('ss_export_png')?.addEventListener('click', ()=>{ if (!ssChart) return; exportChartHiRes(ssChart, 'aql_oc_chart'); });
    document.getElementById('ss_export_csv')?.addEventListener('click', ()=>{ if (!ssChart||!ssLastPlan||ssLastPlan.c==null) return; let csv='x_defect_rate_percent,y_acceptance_prob,n,c,N,AQL,code_letter,inspection_level,distribution\n'; ssChart.data.datasets[0].data.forEach(p=>{ csv+=`${p.x},${p.y},${ssLastPlan.n},${ssLastPlan.c},${ssLastPlan.N},${ssLastPlan.aql},${ssLastPlan.code},${ssLastPlan.level},${ssLastPlan.dist}\n`; }); const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='aql_oc_chart.csv'; a.click(); URL.revokeObjectURL(url); });
    // export plan to queue
    (function(){
        var btn = document.getElementById('ss_export_plan');
        if (!btn) return;
        btn.addEventListener('click', function(){
            if (!ssLastPlan || ssLastPlan.c==null){ alert('No plan to export. Please lookup first.'); return; }
            window.planComparisonQueue = window.planComparisonQueue || [];
            var distName = ssLastPlan.dist === 'hyper' ? 'Hypergeometric' : (ssLastPlan.dist === 'binom' ? 'Binomial' : 'Poisson');
            var label = 'AQL '+ssLastPlan.aql+' (Code '+ssLastPlan.code+', '+distName+')';
            // Calculate efficiency data for consistent rating
            const aql = parseFloat(ssLastPlan.aql);
            const paAql = calculateAcceptanceProbability(ssLastPlan.n, ssLastPlan.c, aql / 100, ssLastPlan.N, ssLastPlan.dist);
            const ltpd = aql * 2; // Assume LTPD is 2x AQL for standard plans
            const paLtpd = calculateAcceptanceProbability(ssLastPlan.n, ssLastPlan.c, ltpd / 100, ssLastPlan.N, ssLastPlan.dist);
            const actualAlpha = 1 - paAql;
            const actualBeta = paLtpd;
            
            window.planComparisonQueue.push({ 
                n: ssLastPlan.n, 
                c: ssLastPlan.c, 
                aql: aql, 
                label: label,
                dist: ssLastPlan.dist,
                N: ssLastPlan.N,
                source: 'aql',
                // Include efficiency calculation data
                paAql: paAql,
                paLtpd: paLtpd,
                actualAlpha: actualAlpha,
                actualBeta: actualBeta
            });
            alert('Exported to Plan Comparison queue. Switch to Multiple Plan Comparison to import.');
        });
    })();

    // Initialize selects
    populateInspectionLevels(); populateAqlLevels();

    // ===== Interactive Tutorial System =====
    const tutorialSteps = [
        {
            title: "🎯 Welcome to Sampling Plan Analysis!",
            content: `
                <h3>What is Statistical Sampling?</h3>
                <p>Statistical sampling is a quality control method where we inspect only a small portion of a production lot to make decisions about the entire lot's quality.</p>
                
                <div class="highlight-box">
                    <strong>🎯 Key Concept:</strong> Instead of checking every single item (which is expensive and time-consuming), we use mathematical models to determine how many items to inspect and what acceptance criteria to use.
                </div>
                
                <div class="example-box">
                    <strong>📦 Real Example:</strong> You receive 10,000 electronic components. Instead of testing all 10,000, you might test only 125 components. If 2 or fewer are defective, you accept the entire lot. If 3 or more are defective, you reject it.
                </div>
                
                <p>This tutorial will teach you how to design and analyze these sampling plans using three different statistical models!</p>
            `,
            highlight: null
        },
        {
            title: "📊 Understanding OC Curves",
            content: `
                <h3>What is an Operating Characteristic (OC) Curve?</h3>
                <p>An OC curve shows the probability of accepting a lot based on its true defect rate. It's the heart of sampling plan analysis!</p>
                
                <div class="highlight-box">
                    <strong>📈 How to Read an OC Curve:</strong>
                    <ul>
                        <li><strong>X-axis:</strong> True defect rate in the lot (%)</li>
                        <li><strong>Y-axis:</strong> Probability of accepting the lot (%)</li>
                        <li><strong>Ideal curve:</strong> High acceptance for good lots, low acceptance for bad lots</li>
                    </ul>
                </div>
                
                <div class="example-box">
                    <strong>🎯 Example:</strong> If your lot has a 1% defect rate, you want a 95% chance of accepting it. If it has a 5% defect rate, you might want only a 10% chance of accepting it.
                </div>
                
                <p>The steeper the curve, the better it discriminates between good and bad lots!</p>
            `,
            highlight: '#ocChart'
        },
        {
            title: "🔢 Three Statistical Models",
            content: `
                <h3>Why Different Probability Distributions?</h3>
                <p>The choice of statistical model depends on your sampling conditions:</p>
                
                <div class="highlight-box">
                    <strong>🟡 Hypergeometric (Most Accurate):</strong>
                    <ul>
                        <li>Use when: Finite lot size, sampling without replacement</li>
                        <li>Example: Testing 50 items from a lot of 500</li>
                        <li>Considers lot depletion effect</li>
                    </ul>
                </div>
                
                <div class="example-box">
                    <strong>🟢 Binomial (Most Common):</strong>
                    <ul>
                        <li>Use when: Large lot size or sampling with replacement</li>
                        <li>Example: Testing 125 items from a lot of 100,000</li>
                        <li>Assumes constant defect probability</li>
                    </ul>
                </div>
                
                <div class="warning-box">
                    <strong>🔴 Poisson (Approximation):</strong>
                    <ul>
                        <li>Use when: Large sample size, small defect rate</li>
                        <li>Example: n > 50 and defect rate < 5%</li>
                        <li>Computational convenience</li>
                    </ul>
                </div>
            `,
            highlight: '[data-dist]'
        },
        {
            title: "🎮 Interactive Demo: Try It!",
            content: `
                <h3>Let's Experiment with Parameters!</h3>
                <p>Now let's see how changing parameters affects the OC curve. Try these experiments:</p>
                
                <div class="tutorial-interactive-demo">
                    <strong>🧪 Experiment 1: Sample Size Effect</strong>
                    <ol>
                        <li>Set N=1000, n=50, c=2</li>
                        <li>Now change n to 100, then 200</li>
                        <li>Notice how larger sample sizes make steeper curves!</li>
                    </ol>
                </div>
                
                <div class="tutorial-interactive-demo">
                    <strong>🧪 Experiment 2: Acceptance Number Effect</strong>
                    <ol>
                        <li>Set N=1000, n=125, c=1</li>
                        <li>Now change c to 3, then 5</li>
                        <li>Higher c values shift the curve to the right!</li>
                    </ol>
                </div>
                
                <div class="tutorial-interactive-demo">
                    <strong>🧪 Experiment 3: Distribution Comparison</strong>
                    <ol>
                        <li>Set N=500, n=50, c=2</li>
                        <li>Toggle between Hypergeometric, Binomial, and Poisson</li>
                        <li>See how they differ for small lot sizes!</li>
                    </ol>
                </div>
            `,
            highlight: '.parameters'
        },
        {
            title: "🎯 AQL and Quality Standards",
            content: `
                <h3>Understanding Acceptable Quality Level (AQL)</h3>
                <p>AQL is the maximum defect rate you're willing to accept most of the time (typically 95% acceptance probability).</p>
                
                <div class="highlight-box">
                    <strong>🎯 AQL Concept:</strong>
                    <ul>
                        <li><strong>AQL 1.0%:</strong> You accept lots with 1% defects 95% of the time</li>
                        <li><strong>AQL 2.5%:</strong> You accept lots with 2.5% defects 95% of the time</li>
                        <li><strong>Lower AQL = Stricter quality requirements</strong></li>
                    </ul>
                </div>
                
                <div class="example-box">
                    <strong>📋 Industry Standards (ANSI/ASQ Z1.4):</strong>
                    <ul>
                        <li>Critical defects: AQL 0.15% or lower</li>
                        <li>Major defects: AQL 1.0% to 2.5%</li>
                        <li>Minor defects: AQL 4.0% to 6.5%</li>
                    </ul>
                </div>
                
                <p>The AQL Plan Table Lookup page helps you find standard sampling plans based on your lot size and desired AQL!</p>
            `,
            highlight: null
        },
        {
            title: "🔄 Reverse Engineering Plans",
            content: `
                <h3>Working Backwards from Requirements</h3>
                <p>Sometimes you know your quality requirements but need to find the right sampling plan parameters.</p>
                
                <div class="highlight-box">
                    <strong>🔄 Reverse Query Scenarios:</strong>
                    <ul>
                        <li><strong>Find AQL:</strong> Given n, c, and target acceptance rate</li>
                        <li><strong>Find Sample Size:</strong> Given AQL, c, and target acceptance rate</li>
                        <li><strong>Find Acceptance Number:</strong> Given n, AQL, and target acceptance rate</li>
                        <li><strong>Find Lot Size:</strong> For hypergeometric plans</li>
                    </ul>
                </div>
                
                <div class="example-box">
                    <strong>🎯 Example Problem:</strong>
                    <p>"I want to accept lots with 1% defects at least 95% of the time, and I can only inspect 100 items with c=2. What's my actual AQL?"</p>
                    <p><strong>Solution:</strong> Use Reverse Query to calculate AQL ≈ 1.24%</p>
                </div>
                
                <p>This is powerful for validating existing plans or designing custom ones!</p>
            `,
            highlight: null
        },
        {
            title: "📊 Comparing Multiple Plans",
            content: `
                <h3>Plan Comparison and Optimization</h3>
                <p>Different sampling plans have different risk profiles. The Multiple Plan Comparison page helps you visualize and choose the best one.</p>
                
                <div class="highlight-box">
                    <strong>⚠️ Important Statistical Concept:</strong>
                    <p>Plans from different pages may use different probability distributions (Hypergeometric/Binomial/Poisson). Even with the same n,c values, they can produce different OC curves!</p>
                </div>
                
                <div class="example-box">
                    <strong>🔍 Comparison Strategies:</strong>
                    <ul>
                        <li><strong>Risk Analysis:</strong> Compare producer's risk (α) and consumer's risk (β)</li>
                        <li><strong>Cost Analysis:</strong> Balance inspection costs vs. quality costs</li>
                        <li><strong>Discrimination:</strong> Choose plans with steeper OC curves</li>
                    </ul>
                </div>
                
                <div class="warning-box">
                    <strong>🎯 Pro Tip:</strong> Export plans from different pages to compare their performance under various statistical assumptions!
                </div>
            `,
            highlight: null
        },
        {
            title: "📈 Advanced Curve Analysis: AOQ & ATI",
            content: `
                <h3>Beyond OC Curves: Quality and Cost Analysis</h3>
                <p>The Multiple Plan Comparison page now supports three types of curves for comprehensive plan evaluation:</p>
                
                <div class="highlight-box">
                    <strong>📊 OC Curves (Operating Characteristic):</strong>
                    <ul>
                        <li>Shows acceptance probability vs. defect rate</li>
                        <li>Primary tool for risk assessment</li>
                        <li>Steeper curves = better discrimination</li>
                    </ul>
                </div>
                
                <div class="example-box">
                    <strong>📈 AOQ Curves (Average Outgoing Quality):</strong>
                    <ul>
                        <li>Formula: AOQ = p × Pa × (N-n)/N</li>
                        <li>Shows average quality of accepted lots</li>
                        <li>Lower AOQ = better quality protection</li>
                        <li>Peak AOQ indicates maximum outgoing quality</li>
                    </ul>
                </div>
                
                <div class="warning-box">
                    <strong>💰 ATI Curves (Average Total Inspection):</strong>
                    <ul>
                        <li>Formula: ATI = n + (1-Pa) × (N-n)</li>
                        <li>Shows average inspection cost per lot</li>
                        <li>Lower ATI = more cost-effective</li>
                        <li>Balances sample size vs. 100% inspection</li>
                    </ul>
                </div>
                
                <p><strong>🎯 Usage:</strong> Click "Show AOQ Curves" or "Show ATI Curves" buttons to switch between different analysis modes!</p>
            `,
            highlight: null
        },
        {
            title: "⚖️ AQL-LTPD Balanced Plans",
            content: `
                <h3>Advanced Optimization: Balancing Producer and Consumer Risks</h3>
                <p>The AQL-LTPD Balanced Plan page uses mathematical optimization to design plans that balance both producer and consumer requirements.</p>
                
                <div class="highlight-box">
                    <strong>🎯 Key Concepts:</strong>
                    <ul>
                        <li><strong>AQL (Acceptable Quality Level):</strong> Maximum defect rate you accept 95% of the time</li>
                        <li><strong>LTPD (Lot Tolerance Percent Defective):</strong> Maximum defect rate you accept 10% of the time</li>
                        <li><strong>Producer's Risk (α):</strong> Probability of rejecting a good lot</li>
                        <li><strong>Consumer's Risk (β):</strong> Probability of accepting a bad lot</li>
                    </ul>
                </div>
                
                <div class="example-box">
                    <strong>🔧 Optimization Strategies:</strong>
                    <ul>
                        <li><strong>Minimize Sample Size:</strong> Find smallest n that meets constraints</li>
                        <li><strong>Balance AQL-LTPD:</strong> Equal weight to both requirements</li>
                        <li><strong>Maximize Producer Protection:</strong> Minimize producer's risk</li>
                        <li><strong>Maximize Consumer Protection:</strong> Minimize consumer's risk</li>
                    </ul>
                </div>
                
                <div class="warning-box">
                    <strong>📊 Plan Efficiency Formula:</strong>
                    <p>E = 1 - |Pa_AQL - (1-α)| - |Pa_LTPD - β| - penalty</p>
                    <p>Higher efficiency = better balance of risks and requirements</p>
                </div>
                
                <p><strong>🎯 Usage:</strong> Set your AQL, LTPD, lot size, and risk preferences, then choose optimization strategy!</p>
            `,
            highlight: null
        },
        {
            title: "🎓 Quiz: Test Your Knowledge!",
            content: `
                <h3>Quick Knowledge Check</h3>
                <p>Randomly selected questions. Click the correct answer:</p>
                <div id="tutorial-quiz-container"></div>
                <div style="margin-top: 16px; display:flex; gap:8px; align-items:center;">
                    <button id="quiz-refresh-btn" class="btn">Refresh Quiz</button>
                    <span style="color: var(--muted); font-style: italic;">Each refresh pulls new questions covering key sampling plan topics.</span>
                </div>
            `,
            highlight: null,
            isQuiz: true
        }
    ];

    // ===== Quiz bank (>=50 questions) =====
    const quizQuestionBank = [
        { q: 'Which distribution applies to finite lots with sampling without replacement?', options: ['Hypergeometric', 'Binomial', 'Poisson'], answer: 0 },
        { q: 'For very large (or effectively infinite) lots with constant defect rate, which distribution is typical?', options: ['Hypergeometric', 'Binomial', 'Poisson'], answer: 1 },
        { q: 'When sample size is large and defect rate is small, which approximation is commonly used?', options: ['Poisson', 'Binomial', 'Normal'], answer: 0 },
        { q: 'On an OC curve, what does the y-axis represent?', options: ['Defect rate', 'Acceptance probability (Pa)', 'Sample size'], answer: 1 },
        { q: 'On an OC curve, what is usually on the x-axis?', options: ['Defect rate p (%)', 'Sample size n', 'AQL value'], answer: 0 },
        { q: 'What does AQL 1.0% typically mean?', options: ['Allow 1% defects', 'Lots with 1% defects are accepted about 95% of the time', 'Average defect rate equals 1%'], answer: 1 },
        { q: 'Under the same distribution, increasing n tends to make the OC curve…', options: ['Steeper', 'Flatter', 'Unchanged'], answer: 0 },
        { q: 'With the same n, increasing c tends to shift the curve…', options: ['To the right', 'To the left', 'No shift'], answer: 0 },
        { q: 'In a C=0 plan, what is c?', options: ['0', '1', '2'], answer: 0 },
        { q: 'In plan parameters (n, c), what does c denote?', options: ['Sample size', 'Acceptance number', 'Lot size'], answer: 1 },
        { q: 'Given N=500, n=50, without replacement, which distribution?', options: ['Binomial', 'Hypergeometric', 'Poisson'], answer: 1 },
        { q: 'A smaller AQL indicates…', options: ['Looser control', 'Stricter control', 'No relation to strictness'], answer: 1 },
        { q: 'Which pages can export a plan to Multiple Plan Comparison?', options: ['Reverse', 'AQL Lookup', 'Both'], answer: 2 },
        { q: 'Where do you set the x-axis maximum on the Comparison chart?', options: ['Left parameters panel', 'Chart toolbar (top-right)', 'Hidden setting'], answer: 1 },
        { q: 'In hypergeometric distribution, which extra parameter is required?', options: ['Lot size N', 'Lambda', 'Mean'], answer: 0 },
        { q: 'The Poisson parameter is typically approximated as…', options: ['n·p', 'n/p', 'n+p'], answer: 0 },
        { q: 'To display an AQL marker on the chart, you must provide…', options: ['AQL (%)', 'LTPD (%)', 'α and β risks'], answer: 0 },
        { q: 'A steeper OC curve implies…', options: ['Better discrimination', 'Worse discrimination', 'Cannot tell'], answer: 0 },
        { q: 'On the Reverse page you can solve for…', options: ['AQL', 'n', 'c', 'All of the above'], answer: 3 },
        { q: 'A common use case of C=0 plans is…', options: ['High-risk critical defects', 'General inspection', 'Documentation'], answer: 0 },
        { q: 'For Binomial, the acceptance probability uses CDF(c; n, p). Here p means…', options: ['Sample proportion', 'Defect rate', 'Pass rate'], answer: 1 },
        { q: 'For Poisson in sampling, λ is often…', options: ['n·p', 'p/n', 'n/p'], answer: 0 },
        { q: 'Across different distributions, OC curves for the same (n, c) can be…', options: ['Identical', 'Different', 'Not drawable'], answer: 1 },
        { q: 'When N is very large, sampling without replacement can be approximated by…', options: ['Binomial', 'Hypergeometric', 'Poisson'], answer: 0 },
        { q: 'The AQL lookup page references which standard?', options: ['ANSI/ASQ Z1.4', 'MIL-STD-105E', 'ISO 9001'], answer: 0 },
        { q: 'To compare plans, you should examine…', options: ['OC curve shape/shift', 'x-axis unit only', 'Chart background color'], answer: 0 },
        { q: 'Increasing c typically affects producer’s risk (α) by…', options: ['Increasing', 'Decreasing', 'No change'], answer: 1 },
        { q: 'Increasing n typically affects consumer’s risk (β) by…', options: ['Increasing', 'Decreasing', 'No change'], answer: 1 },
        { q: 'In this tool, Pa ranges between…', options: ['0–100', '0–1', '1–100'], answer: 1 },
        { q: 'The x-axis p values are expressed in…', options: ['Decimal fraction', 'Percent (%)', 'Per mille (‰)'], answer: 1 },
        { q: 'If AQL=2.5%, a typical Pa at p=2.5% is…', options: ['≈95%', '≈50%', '≈5%'], answer: 0 },
        { q: 'Poisson approximation is most suitable for…', options: ['Small n, high p', 'Large n, small p', 'Any case'], answer: 1 },
        { q: 'Key parameters for Hypergeometric are…', options: ['N, n, c, p', 'n, c, p', 'N, p'], answer: 0 },
        { q: 'Are AQL dots shown in the legend on Comparison?', options: ['Shown', 'Hidden', 'Configurable'], answer: 1 },
        { q: 'AQL marker tooltip shows…', options: ['p only', 'Pa only', 'p and Pa'], answer: 2 },
        { q: 'Default unit for target Pa on Reverse page is…', options: ['%', 'Decimal', 'Not displayed'], answer: 0 },
        { q: 'If n < c, the app will…', options: ['Show an error', 'Proceed normally', 'Auto-correct'], answer: 0 },
        { q: 'Chart export buttons are located…', options: ['Left side', 'Chart toolbar', 'Footer'], answer: 1 },
        { q: 'In Multiple Plan Comparison, newly added manual plans default to…', options: ['Hypergeometric', 'Binomial', 'Poisson'], answer: 1 },
        { q: 'Main difference between Binomial and Hypergeometric?', options: ['With/without replacement', 'Sample size only', 'Presence of AQL'], answer: 0 },
        { q: 'To consider lot depletion effect, choose…', options: ['Binomial', 'Hypergeometric', 'Poisson'], answer: 1 },
        { q: 'When comparing different (n, c) plans, recommended approach?', options: ['View one curve only', 'Visualize multiple curves together', 'Rely on text'], answer: 1 },
        { q: 'Typical acceptance probability at AQL?', options: ['50%', '80%', '95%'], answer: 2 },
        { q: 'To tighten inspection stringency you could…', options: ['Lower n', 'Lower c or increase n', 'Do nothing'], answer: 1 },
        { q: 'LTPD commonly describes…', options: ['A consumer-risk point for bad lots', 'Average defect rate', 'Best cost'], answer: 0 },
        { q: 'Label on the randomize button should be…', options: ['Refresh questions', 'Refresh Quiz', 'Reset quiz'], answer: 1 },
        { q: 'If distributions differ but (n, c) are the same, OC can be…', options: ['Exactly the same', 'Slightly different', 'Not drawable'], answer: 1 },
        { q: 'An advantage of C=0 for high-risk defects is…', options: ['Looser acceptance threshold', 'Lower consumer risk', 'Higher producer risk'], answer: 1 },
        { q: 'Position of the AQL marker is determined by…', options: ['AQL and Pa(AQL)', 'n and c', 'N and n'], answer: 0 },
        { q: 'After changing x-axis max in Comparison, AQL dots…', options: ['Do not update', 'Update automatically', 'Require page reload'], answer: 1 },
        { q: 'Can the Reverse page export a plan to Comparison?', options: ['Yes', 'No', 'C=0 only'], answer: 0 },
        { q: 'Can the AQL Lookup page export a plan?', options: ['Yes', 'No', 'Hypergeometric only'], answer: 0 },
        { q: 'What does AOQ stand for?', options: ['Average Outgoing Quality', 'Acceptable Quality Level', 'Average Quality Output'], answer: 0 },
        { q: 'What does ATI stand for?', options: ['Average Total Inspection', 'Acceptable Total Inspection', 'Average Test Items'], answer: 0 },
        { q: 'AOQ formula is: AOQ = p × Pa × (N-n)/N. What does p represent?', options: ['Sample size', 'Defect rate', 'Acceptance probability'], answer: 1 },
        { q: 'ATI formula is: ATI = n + (1-Pa) × (N-n). What does (1-Pa) represent?', options: ['Acceptance probability', 'Rejection probability', 'Defect rate'], answer: 1 },
        { q: 'In the AQL-LTPD Balanced Plan page, what does "Minimize Sample Size" optimization do?', options: ['Find largest n', 'Find smallest n that meets constraints', 'Balance n and c'], answer: 1 },
        { q: 'Plan Efficiency formula includes which components?', options: ['Only AQL deviation', 'AQL deviation + LTPD deviation + penalty', 'Only LTPD deviation'], answer: 1 },
        { q: 'Which curve type shows inspection costs?', options: ['OC curves', 'AOQ curves', 'ATI curves'], answer: 2 },
        { q: 'Which curve type shows outgoing quality?', options: ['OC curves', 'AOQ curves', 'ATI curves'], answer: 1 },
        { q: 'In Multiple Plan Comparison, how many curve types can you display?', options: ['1 (OC only)', '2 (OC and AOQ)', '3 (OC, AOQ, ATI)'], answer: 2 },
        { q: 'What happens when you change max defect rate in AOQ mode?', options: ['Switches to OC mode', 'Stays in AOQ mode', 'Shows error'], answer: 1 },
        { q: 'ATI curves show values in which unit?', options: ['Percentage (%)', 'Count (number)', 'Decimal (0-1)'], answer: 1 },
        { q: 'AOQ curves show values in which unit?', options: ['Percentage (%)', 'Count (number)', 'Decimal (0-1)'], answer: 0 },
        { q: 'What is the purpose of AQL-LTPD Balanced Plans?', options: ['Find standard plans', 'Optimize plans balancing both risks', 'Calculate C=0 plans'], answer: 1 },
        { q: 'Which optimization strategy gives equal weight to AQL and LTPD?', options: ['Minimize Sample Size', 'Balance AQL-LTPD', 'Maximize Producer Protection'], answer: 1 }
    ];

    function shuffleArray(arr){ for (let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
    function renderRandomQuiz(count=6){
        const container = document.getElementById('tutorial-quiz-container'); if (!container) return;
        container.innerHTML = '';
        const picked = shuffleArray([...quizQuestionBank]).slice(0, Math.max(5, count));
        picked.forEach((item, idx)=>{
            const wrap = document.createElement('div'); wrap.className = 'tutorial-quiz';
            const q = document.createElement('p'); q.innerHTML = `<strong>Question ${idx+1}:</strong> ${item.q}`; wrap.appendChild(q);
            item.options.forEach((opt, i)=>{
                const div = document.createElement('div'); div.className='tutorial-quiz-option'; div.setAttribute('data-correct', String(i===item.answer)); div.textContent = opt; wrap.appendChild(div);
            });
            container.appendChild(wrap);
        });
        // Attach option handlers
        setTimeout(()=>{
            container.querySelectorAll('.tutorial-quiz-option').forEach(option => {
                option.addEventListener('click', function(){
                    const isCorrect = this.getAttribute('data-correct') === 'true';
                    this.classList.add(isCorrect ? 'correct' : 'incorrect');
                    const quiz = this.closest('.tutorial-quiz');
                    quiz.querySelectorAll('.tutorial-quiz-option').forEach(opt => { if (opt !== this) opt.style.pointerEvents = 'none'; });
                    if (isCorrect) { this.innerHTML += ' ✅ Correct'; }
                    else {
                        this.innerHTML += ' ❌ Try again!';
                        setTimeout(()=>{ const correct = quiz.querySelector('[data-correct="true"]'); if (correct){ correct.classList.add('correct'); correct.innerHTML += ' ✅ This is correct!'; } }, 600);
                    }
                });
            });
        }, 50);
    }

    let currentTutorialStep = 0;
    let tutorialActive = false;

    // Tutorial DOM elements
    const tutorialModal = document.getElementById('tutorial-modal');
    const tutorialTitle = document.getElementById('tutorial-title');
    const tutorialStepContent = document.getElementById('tutorial-step-content');
    const tutorialProgressFill = document.getElementById('tutorial-progress-fill');
    const tutorialProgressText = document.getElementById('tutorial-progress-text');
    const tutorialDots = document.getElementById('tutorial-dots');
    const tutorialPrevBtn = document.getElementById('tutorial-prev-btn');
    const tutorialNextBtn = document.getElementById('tutorial-next-btn');
    const tutorialCloseBtn = document.getElementById('tutorial-close-btn');
    const tutorialHighlight = document.getElementById('tutorial-highlight');
    const startTutorialBtn = document.getElementById('start-tutorial-btn');

    // Initialize tutorial
    function initTutorial() {
        // Create dots
        tutorialDots.innerHTML = '';
        tutorialSteps.forEach((_, index) => {
            const dot = document.createElement('div');
            dot.className = `tutorial-dot ${index === 0 ? 'active' : ''}`;
            dot.addEventListener('click', () => goToTutorialStep(index));
            tutorialDots.appendChild(dot);
        });

        // Event listeners
        startTutorialBtn?.addEventListener('click', startTutorial);
        tutorialCloseBtn?.addEventListener('click', closeTutorial);
        tutorialPrevBtn?.addEventListener('click', prevTutorialStep);
        tutorialNextBtn?.addEventListener('click', nextTutorialStep);
        
        // Close on overlay click
        document.querySelector('.tutorial-overlay')?.addEventListener('click', closeTutorial);
        
        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (!tutorialActive) return;
            if (e.key === 'Escape') closeTutorial();
            if (e.key === 'ArrowLeft') prevTutorialStep();
            if (e.key === 'ArrowRight') nextTutorialStep();
        });
    }

    function startTutorial() {
        tutorialActive = true;
        currentTutorialStep = 0;
        tutorialModal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
        updateTutorialStep();
        
        // Add entrance animation
        setTimeout(() => {
            tutorialModal.querySelector('.tutorial-content').style.animation = 'none';
        }, 400);
    }

    function closeTutorial() {
        tutorialActive = false;
        tutorialModal.style.display = 'none';
        tutorialHighlight.style.display = 'none';
        document.body.style.overflow = '';
    }

    function nextTutorialStep() {
        if (currentTutorialStep < tutorialSteps.length - 1) {
            currentTutorialStep++;
            updateTutorialStep();
        } else {
            // Tutorial completed
            setTimeout(() => {
                alert('🎉 Congratulations! You\'ve completed the Sampling Plan Tutorial!\n\nYou\'re now ready to use all the advanced features of this analyzer. Happy sampling! 📊');
                closeTutorial();
            }, 100);
        }
    }

    function prevTutorialStep() {
        if (currentTutorialStep > 0) {
            currentTutorialStep--;
            updateTutorialStep();
        }
    }

    function goToTutorialStep(stepIndex) {
        if (stepIndex >= 0 && stepIndex < tutorialSteps.length) {
            currentTutorialStep = stepIndex;
            updateTutorialStep();
        }
    }

    function updateTutorialStep() {
        const step = tutorialSteps[currentTutorialStep];
        
        // Update content
        tutorialTitle.textContent = step.title;
        tutorialStepContent.innerHTML = step.content;
        
        // Update progress
        const progress = ((currentTutorialStep + 1) / tutorialSteps.length) * 100;
        tutorialProgressFill.style.width = `${progress}%`;
        tutorialProgressText.textContent = `Step ${currentTutorialStep + 1} of ${tutorialSteps.length}`;
        
        // Update dots
        document.querySelectorAll('.tutorial-dot').forEach((dot, index) => {
            dot.classList.toggle('active', index === currentTutorialStep);
        });
        
        // Update navigation buttons
        tutorialPrevBtn.style.display = currentTutorialStep > 0 ? 'block' : 'none';
        tutorialNextBtn.textContent = currentTutorialStep === tutorialSteps.length - 1 ? 'Complete Tutorial! 🎉' : 'Next →';
        
        // Handle highlighting
        if (step.highlight) {
            highlightElement(step.highlight);
        } else {
            tutorialHighlight.style.display = 'none';
        }
        
        // Handle quiz rendering and interactions
        if (step.isQuiz) {
            // Render random quiz set and bind refresh
            setTimeout(()=>{
                renderRandomQuiz(6);
                const btn = document.getElementById('quiz-refresh-btn');
                if (btn){ btn.onclick = function(){ renderRandomQuiz(6); } }
            }, 50);
        }
    }

    function highlightElement(selector) {
        const element = document.querySelector(selector);
        if (!element) return;
        
        const rect = element.getBoundingClientRect();
        tutorialHighlight.style.display = 'block';
        tutorialHighlight.style.left = `${rect.left - 5}px`;
        tutorialHighlight.style.top = `${rect.top - 5}px`;
        tutorialHighlight.style.width = `${rect.width + 10}px`;
        tutorialHighlight.style.height = `${rect.height + 10}px`;
    }

    // ===== AQL-LTPD Balanced Plan Page Functionality =====
    const aqlLtpdElements = {
        aqlInput: document.getElementById('aql_ltpd_aql_input'),
        ltpdInput: document.getElementById('aql_ltpd_ltpd_input'),
        lotSizeInput: document.getElementById('aql_ltpd_lot_size'),
        distSelect: document.getElementById('aql_ltpd_dist_select'),
        optimizationSelect: document.getElementById('aql_ltpd_optimization'),
        alphaInput: document.getElementById('aql_ltpd_alpha'),
        betaInput: document.getElementById('aql_ltpd_beta'),
        calculateBtn: document.getElementById('aql_ltpd_calculate_btn'),
        clearBtn: document.getElementById('aql_ltpd_clear_btn'),
        errorDiv: document.getElementById('aql_ltpd_error'),
        resultN: document.getElementById('aql_ltpd_result_n'),
        resultC: document.getElementById('aql_ltpd_result_c'),
        efficiency: document.getElementById('aql_ltpd_efficiency'),
        aqlPa: document.getElementById('aql_ltpd_aql_pa'),
        ltpdPa: document.getElementById('aql_ltpd_ltpd_pa'),
        actualAlpha: document.getElementById('aql_ltpd_actual_alpha'),
        actualBeta: document.getElementById('aql_ltpd_actual_beta'),
        aoql: document.getElementById('aql_ltpd_aoql'),
        asn: document.getElementById('aql_ltpd_asn'),
        efficiencyRating: document.getElementById('aql_ltpd_efficiency_rating'),
        improvements: document.getElementById('aql_ltpd_improvements'),
        notes: document.getElementById('aql_ltpd_notes'),
        xMaxInput: document.getElementById('aql_ltpd_x_max'),
        exportPngBtn: document.getElementById('aql_ltpd_export_png_toolbar'),
        exportCsvBtn: document.getElementById('aql_ltpd_export_csv_toolbar'),
        exportPlanBtn: document.getElementById('aql_ltpd_export_plan')
    };

    let aqlLtpdChart = null;
    let aqlLtpdLastPlan = null;

    // AQL-LTPD Optimization Algorithm
    function calculateOptimalAqlLtpdPlan(aql, ltpd, lotSize, distribution, optimizationTarget, alpha, beta) {
        // Input validation
        if (aql >= ltpd) {
            throw new Error('AQL must be less than LTPD');
        }
        if (alpha <= 0 || alpha >= 1 || beta <= 0 || beta >= 1) {
            throw new Error('Risk values must be between 0 and 1');
        }

        const idealPaAql = 1 - alpha; // Ideal acceptance probability at AQL
        const idealPaLtpd = beta;     // Ideal acceptance probability at LTPD

        let bestPlan = null;
        let bestScore = Infinity;
        let feasiblePlans = []; // Track plans that satisfy constraints

        // Search space: n from 1 to 500, c from 0 to n
        for (let n = 1; n <= 500; n++) {
            for (let c = 0; c <= n; c++) {
                try {
                    // Calculate Pa at AQL and LTPD points
                    const paAql = calculateAcceptanceProbability(n, c, aql / 100, lotSize, distribution);
                    const paLtpd = calculateAcceptanceProbability(n, c, ltpd / 100, lotSize, distribution);

                    // Calculate actual risks
                    const actualAlpha = 1 - paAql;
                    const actualBeta = paLtpd;

                    // Calculate score based on optimization target
                    let score;
                    switch (optimizationTarget) {
                        case 'minimize_n':
                            // Minimize sample size while satisfying risk constraints
                            if (actualAlpha <= alpha && actualBeta <= beta) {
                                score = n; // Lower n is better
                            } else {
                                continue; // Skip if constraints not satisfied
                            }
                            break;
                        case 'balance':
                            // Balance AQL-LTPD performance with penalty for constraint violations
                            const aqlDeviation = Math.abs(paAql - idealPaAql);
                            const ltpdDeviation = Math.abs(paLtpd - idealPaLtpd);
                            
                            // Add penalty for constraint violations
                            let constraintPenalty = 0;
                            if (actualAlpha > alpha) {
                                constraintPenalty += (actualAlpha - alpha) * 10; // Heavy penalty
                            }
                            if (actualBeta > beta) {
                                constraintPenalty += (actualBeta - beta) * 10; // Heavy penalty
                            }
                            
                            score = aqlDeviation + ltpdDeviation + constraintPenalty;
                            break;
                        case 'max_producer':
                            // Maximize producer protection (minimize actual alpha)
                            score = actualAlpha;
                            break;
                        case 'max_consumer':
                            // Maximize consumer protection (minimize actual beta)
                            score = actualBeta;
                            break;
                        default:
                            score = n; // Default to minimize sample size
                    }

                    // Track feasible plans (those that satisfy constraints)
                    const isFeasible = (actualAlpha <= alpha && actualBeta <= beta);
                    if (isFeasible) {
                        feasiblePlans.push({
                            n: n,
                            c: c,
                            paAql: paAql,
                            paLtpd: paLtpd,
                            actualAlpha: actualAlpha,
                            actualBeta: actualBeta,
                            score: score
                        });
                    }

                    // Update best plan if this is better
                    if (score < bestScore) {
                        bestScore = score;
                        bestPlan = {
                            n: n,
                            c: c,
                            paAql: paAql,
                            paLtpd: paLtpd,
                            actualAlpha: actualAlpha,
                            actualBeta: actualBeta,
                            score: score
                        };
                    }
                } catch (e) {
                    // Skip invalid combinations
                    continue;
                }
            }
        }

        // For minimize_n optimization, ensure we get the smallest feasible n
        if (optimizationTarget === 'minimize_n' && feasiblePlans.length > 0) {
            // Find the plan with minimum n among feasible plans
            const minNPlan = feasiblePlans.reduce((min, plan) => 
                plan.n < min.n ? plan : min
            );
            return minNPlan;
        }

        return bestPlan;
    }

    // Validate acceptance probability and ensure it's within [0, 1] range
    function validateAcceptanceProbability(pa, context = '') {
        if (pa < 0) {
            console.warn(`Negative acceptance probability detected: ${pa} ${context}`);
            return 0;
        }
        if (pa > 1) {
            console.warn(`Acceptance probability > 100% detected: ${pa} ${context}`);
            return 1;
        }
        if (!isFinite(pa)) {
            console.warn(`Invalid acceptance probability detected: ${pa} ${context}`);
            return 0;
        }
        return pa;
    }

    // Calculate acceptance probability for given parameters
    function calculateAcceptanceProbability(n, c, p, N, distribution) {
        // Add input parameter validation
        if (p < 0 || p > 1) {
            console.warn('Invalid probability p:', p);
            p = Math.max(0, Math.min(1, p));
        }
        
        // Special handling for extremely low defect rates
        if (p === 0) {
            // Perfect quality: always accept if c >= 0
            return c >= 0 ? 1 : 0;
        }
        
        let result;
        switch (distribution) {
            case 'binom':
                result = binomialCDF(c, n, p);
                break;
            case 'pois':
                result = poissonCDF(c, n * p);
                break;
            case 'hyper':
                if (N === null || N === undefined) {
                    throw new Error('Lot size required for Hypergeometric distribution');
                }
                const K = Math.round(N * p);
                result = hypergeometricCDF(c, N, K, n);
                break;
            default:
                result = binomialCDF(c, n, p);
        }
        
        // Ensure result is within [0, 1] range
        return validateAcceptanceProbability(result, `(n=${n}, c=${c}, p=${p}, distribution=${distribution})`);
    }

    // Statistical distribution functions (reuse existing ones)
    function binomialCDF(k, n, p) {
        // Add boundary condition checks
        if (k < 0) return 0;
        if (k >= n) return 1;
        if (p <= 0) return k === 0 ? 1 : 0;
        if (p >= 1) return 1;
        
        // For very small p, use more precise calculation to avoid numerical issues
        if (p < 1e-10) {
            // When p is extremely small, P(X <= k) ≈ 1 for any reasonable k
            return 1;
        }
        
        let sum = 0;
        for (let i = 0; i <= k; i++) {
            sum += binomialPMF(i, n, p);
            // Prevent numerical overflow
            if (sum > 1) return 1;
        }
        return Math.min(1, sum);
    }

    function binomialPMF(k, n, p) {
        if (k < 0 || k > n) return 0;
        if (p === 0) return k === 0 ? 1 : 0;
        if (p === 1) return k === n ? 1 : 0;
        
        let result = 1;
        for (let i = 1; i <= k; i++) {
            result *= (n - i + 1) * p / (i * (1 - p));
        }
        return result * Math.pow(1 - p, n - k);
    }

    function poissonCDF(k, lambda) {
        if (lambda <= 0) return k >= 0 ? 1 : 0;
        if (lambda > 100) {
            // Use normal approximation to avoid numerical underflow
            const mean = lambda;
            const variance = lambda;
            const z = (k + 0.5 - mean) / Math.sqrt(variance);
            // Simple normal approximation
            return 0.5 * (1 + Math.sign(z) * Math.sqrt(1 - Math.exp(-2 * z * z / Math.PI)));
        }
        
        let sum = 0;
        for (let i = 0; i <= k; i++) {
            sum += Math.exp(-lambda) * Math.pow(lambda, i) / factorial(i);
            if (sum > 1) return 1;
        }
        return Math.min(1, sum);
    }

    function hypergeometricCDF(k, N, K, n) {
        if (n > N || K > N || k > Math.min(n, K)) return 0;
        if (k < 0) return 0;
        if (k >= Math.min(n, K)) return 1;
        
        let sum = 0;
        for (let i = 0; i <= k; i++) {
            sum += hypergeometricPMF(i, N, K, n);
            if (sum > 1) return 1;
        }
        return Math.min(1, sum);
    }

    function hypergeometricPMF(k, N, K, n) {
        if (k < 0 || k > n || k > K || n - k > N - K) return 0;
        
        const numerator = combination(K, k) * combination(N - K, n - k);
        const denominator = combination(N, n);
        return numerator / denominator;
    }

    function combination(n, k) {
        if (k > n || k < 0) return 0;
        if (k === 0 || k === n) return 1;
        
        let result = 1;
        for (let i = 1; i <= k; i++) {
            result *= (n - i + 1) / i;
        }
        return result;
    }

    function factorial(n) {
        if (n <= 1) return 1;
        let result = 1;
        for (let i = 2; i <= n; i++) {
            result *= i;
        }
        return result;
    }

    // Calculate AOQL (Average Outgoing Quality Limit)
    function calculateAOQL(n, c, p, N, distribution) {
        // Simplified AOQL calculation - in practice this would be more complex
        const pa = calculateAcceptanceProbability(n, c, p, N, distribution);
        return p * pa; // Simplified version
    }

    // Calculate ASN (Average Sample Number)
    function calculateASN(n, c, p, N, distribution) {
        // For single sampling plans, ASN = n
        // For more complex plans (double, multiple), this would be more sophisticated
        return n;
    }
    
    // Calculate Plan Efficiency Score
    function calculatePlanEfficiency(plan, idealPaAql, idealPaLtpd, alpha, beta) {
        // Calculate efficiency based on how close the plan is to ideal performance
        const aqlDeviation = Math.abs(plan.paAql - idealPaAql);
        const ltpdDeviation = Math.abs(plan.paLtpd - idealPaLtpd);
        
        // Penalty for constraint violations
        let constraintPenalty = 0;
        if (plan.actualAlpha > alpha) {
            constraintPenalty += (plan.actualAlpha - alpha) * 2;
        }
        if (plan.actualBeta > beta) {
            constraintPenalty += (plan.actualBeta - beta) * 2;
        }
        
        // Efficiency score (0-1, higher is better)
        const totalDeviation = aqlDeviation + ltpdDeviation + constraintPenalty;
        const efficiency = Math.max(0, 1 - totalDeviation);
        
        return efficiency;
    }
    
    // Calculate Efficiency Rating and Generate Improvement Suggestions
    function calculateEfficiencyRatingAndSuggestions(plan, efficiency, alpha, beta, aql, ltpd, lotSize) {
        const rating = getEfficiencyRating(efficiency);
        const suggestions = generateImprovementSuggestions(plan, efficiency, alpha, beta, aql, ltpd, lotSize);
        
        return { rating, suggestions };
    }
    
    // Get efficiency rating based on efficiency score
    function getEfficiencyRating(efficiency) {
        if (efficiency >= 0.95) return "🌟 Excellent (95%+)";
        if (efficiency >= 0.85) return "✅ Very Good (85-95%)";
        if (efficiency >= 0.75) return "👍 Good (75-85%)";
        if (efficiency >= 0.65) return "⚠️ Fair (65-75%)";
        if (efficiency >= 0.50) return "❌ Poor (50-65%)";
        return "🚫 Very Poor (<50%)";
    }
    
    // Generate improvement suggestions based on plan analysis
    function generateImprovementSuggestions(plan, efficiency, alpha, beta, aql, ltpd, lotSize) {
        const suggestions = [];
        
        // Sample size analysis
        if (plan.n > 200) {
            suggestions.push("• Consider reducing sample size: Current n=" + plan.n + " is quite large. Try adjusting AQL/LTPD values or risk constraints.");
        } else if (plan.n < 20) {
            suggestions.push("• Sample size is very small (n=" + plan.n + "). Consider increasing for better statistical power.");
        }
        
        // Risk constraint analysis
        if (plan.actualAlpha > alpha * 1.2) {
            suggestions.push("• Producer's risk is high (" + (plan.actualAlpha * 100).toFixed(1) + "% vs target " + (alpha * 100) + "%). Consider increasing sample size or adjusting AQL.");
        }
        
        if (plan.actualBeta > beta * 1.2) {
            suggestions.push("• Consumer's risk is high (" + (plan.actualBeta * 100).toFixed(1) + "% vs target " + (beta * 100) + "%). Consider increasing sample size or adjusting LTPD.");
        }
        
        // Efficiency-based suggestions
        if (efficiency < 0.75) {
            suggestions.push("• Plan efficiency is low. Consider:");
            suggestions.push("  - Adjusting AQL/LTPD values for better balance");
            suggestions.push("  - Using different optimization strategy");
            suggestions.push("  - Considering double sampling plans for large lots");
        }
        
        // Distribution-specific suggestions
        if (lotSize < 1000) {
            suggestions.push("• For small lots (N=" + lotSize + "), consider using Hypergeometric distribution for more accurate results.");
        } else if (lotSize > 10000) {
            suggestions.push("• For large lots (N=" + lotSize + "), Binomial or Poisson distributions are appropriate.");
        }
        
        // AQL-LTPD ratio analysis
        const ratio = ltpd / aql;
        if (ratio < 3) {
            suggestions.push("• AQL-LTPD ratio is small (" + ratio.toFixed(1) + "). Consider wider separation for better discrimination.");
        } else if (ratio > 10) {
            suggestions.push("• AQL-LTPD ratio is very large (" + ratio.toFixed(1) + "). This may require very large sample sizes.");
        }
        
        // General recommendations
        if (suggestions.length === 0) {
            suggestions.push("• Plan appears well-balanced. Consider monitoring actual performance and adjusting as needed.");
        }
        
        return suggestions.join('\n');
    }
    

    // Update AQL-LTPD chart
    function updateAqlLtpdChart(plan) {
        if (!plan) return;

        const ctx = document.getElementById('ocChartAQL_LTPD');
        if (!ctx) return;

        const xMax = parseFloat(aqlLtpdElements.xMaxInput?.value || 10);
        const step = 0.001;
        const pValues = [];
        const paValues = [];

        // Generate OC curve data with special handling for low defect rates
        for (let p = 0; p <= xMax / 100; p += step) {
            pValues.push(p * 100);
            try {
                let pa;
                if (p === 0) {
                    // Perfect quality: always accept
                    pa = 1;
                } else if (p < 1e-6) {
                    // Extremely low defect rate: use asymptotic approximation
                    pa = 1 - Math.exp(-plan.n * p * (1 + p/2));
                } else {
                    pa = calculateAcceptanceProbability(plan.n, plan.c, p, 
                        aqlLtpdElements.lotSizeInput?.value || 1000, 
                        aqlLtpdElements.distSelect?.value || 'binom');
                }
                paValues.push(pa);
            } catch (e) {
                paValues.push(NaN);
            }
        }

        // Destroy existing chart
        if (aqlLtpdChart) {
            aqlLtpdChart.destroy();
        }

        // Crosshair plugin for AQL-LTPD Balanced Plan page
        const aqlLtpdCrosshairPlugin = {
            id: 'aqlLtpdCrosshairPlugin',
            afterEvent: function(chart, args){
                const e = args.event; if (!e) return;
                chart._crosshair = chart._crosshair || { x: null, y: null };
                if (e.type==='mousemove'){ chart._crosshair.x = e.x; chart._crosshair.y = e.y; chart.draw(); }
                if (e.type==='mouseout'){ chart._crosshair.x = null; chart._crosshair.y = null; chart.draw(); }
            },
            afterDraw: function(chart){
                const cx = chart._crosshair && chart._crosshair.x; const cy = chart._crosshair && chart._crosshair.y;
                if (cx==null || cy==null) return;
                const ctx = chart.ctx; const area = chart.chartArea; if (!area) return;
                ctx.save();
                ctx.strokeStyle = 'rgba(199,202,207,0.5)';
                ctx.setLineDash([4,4]);
                // vertical line
                ctx.beginPath(); ctx.moveTo(cx, area.top); ctx.lineTo(cx, area.bottom); ctx.stroke();
                // horizontal line
                ctx.beginPath(); ctx.moveTo(area.left, cy); ctx.lineTo(area.right, cy); ctx.stroke();
                // read scale values
                const xScaleRef = chart.scales && chart.scales.x; const yScaleRef = chart.scales && chart.scales.y;
                if (xScaleRef && yScaleRef){
                    const xVal = xScaleRef.getValueForPixel(cx);
                    const yVal = yScaleRef.getValueForPixel(cy);
                    if (isFinite(xVal) && isFinite(yVal)){
                        const xTxt = xVal.toFixed(2) + '%';
                        const yTxt = (yVal*100).toFixed(1) + '%';
                        const label = 'p=' + xTxt + ' , Pa=' + yTxt;
                        ctx.fillStyle = 'rgba(28,42,54,0.9)'; ctx.strokeStyle='rgba(64,84,102,0.9)';
                        ctx.setLineDash([]);
                        const pad = 6; ctx.font = '12px sans-serif';
                        const w = ctx.measureText(label).width + pad*2; const h = 20;
                        const bx = Math.min(Math.max(area.left, cx+8), area.right - w);
                        const by = Math.max(area.top, cy - h - 8);
                        ctx.beginPath(); ctx.roundRect ? ctx.roundRect(bx, by, w, h, 6) : ctx.rect(bx, by, w, h);
                        ctx.fill(); ctx.stroke();
                        ctx.fillStyle = '#e6e9ee'; ctx.fillText(label, bx+pad, by+14);
                    }
                }
                ctx.restore();
            }
        };

        // Create new chart
        aqlLtpdChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: `Balanced Plan (n=${plan.n}, c=${plan.c})`,
                    data: pValues.map((p, i) => ({ x: p, y: paValues[i] })),
                    borderColor: '#1783FF',
                    backgroundColor: 'rgba(23, 131, 255, 0.1)',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1
                }, {
                    label: 'AQL Point',
                    data: [{ x: parseFloat(aqlLtpdElements.aqlInput?.value || 1), y: plan.paAql }],
                    type: 'scatter',
                    backgroundColor: 'rgba(46, 204, 113, 0.8)',
                    borderColor: '#2ecc71',
                    pointRadius: 8,
                    pointHoverRadius: 10
                }, {
                    label: 'LTPD Point',
                    data: [{ x: parseFloat(aqlLtpdElements.ltpdInput?.value || 5), y: plan.paLtpd }],
                    type: 'scatter',
                    backgroundColor: 'rgba(231, 76, 60, 0.8)',
                    borderColor: '#e74c3c',
                    pointRadius: 8,
                    pointHoverRadius: 10
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'AQL-LTPD Balanced Sampling Plan OC Curve',
                        color: getThemeColors().text
                    },
                    legend: {
                        display: true,
                        labels: { color: getThemeColors().text }
                    },
                    tooltip: {
                        enabled: true,
                        callbacks: {
                            label: function(context) {
                                const x = context.parsed && context.parsed.x;
                                const y = context.parsed && context.parsed.y;
                                const datasetLabel = context.dataset.label || '';
                                const xText = (isFinite(x) ? (+x).toFixed(x < 1 ? 3 : 2) : '-');
                                const yText = (isFinite(y) ? (y * 100).toFixed(1) : '-');
                                return `${datasetLabel}: p=${xText}%, Pa=${yText}%`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Defect Rate (%)',
                            color: getThemeColors().text
                        },
                        grid: { color: getThemeColors().grid },
                        ticks: { color: getThemeColors().text },
                        border: { color: getThemeColors().grid }
                    },
                    y: {
                        min: 0,
                        max: 1,
                        title: {
                            display: true,
                            text: 'Acceptance Probability',
                            color: getThemeColors().text
                        },
                        ticks: {
                            callback: function(v) { return (v * 100).toFixed(0) + '%'; },
                            color: getThemeColors().text
                        },
                        grid: { color: getThemeColors().grid },
                        border: { color: getThemeColors().grid }
                    }
                }
            },
            plugins: [aqlLtpdCrosshairPlugin]
        });
    }

    // Event listeners for AQL-LTPD page
    if (aqlLtpdElements.calculateBtn) {
        aqlLtpdElements.calculateBtn.addEventListener('click', function() {
            try {
                // Clear previous errors
                if (aqlLtpdElements.errorDiv) {
                    aqlLtpdElements.errorDiv.style.display = 'none';
                }

                // Get input values
                const aql = parseFloat(aqlLtpdElements.aqlInput?.value || 1);
                const ltpd = parseFloat(aqlLtpdElements.ltpdInput?.value || 5);
                const lotSize = parseInt(aqlLtpdElements.lotSizeInput?.value || 1000);
                const distribution = aqlLtpdElements.distSelect?.value || 'binom';
                const optimization = aqlLtpdElements.optimizationSelect?.value || 'minimize_n';
                const alpha = parseFloat(aqlLtpdElements.alphaInput?.value || 0.05);
                const beta = parseFloat(aqlLtpdElements.betaInput?.value || 0.10);

                // Calculate optimal plan
                const plan = calculateOptimalAqlLtpdPlan(aql, ltpd, lotSize, distribution, optimization, alpha, beta);

                if (!plan) {
                    throw new Error('No feasible plan found. Try adjusting AQL, LTPD, or risk constraints.');
                }

                // Update results
                if (aqlLtpdElements.resultN) aqlLtpdElements.resultN.value = plan.n;
                if (aqlLtpdElements.resultC) aqlLtpdElements.resultC.value = plan.c;
                // Calculate plan efficiency
                const efficiency = calculatePlanEfficiency(plan, 1 - alpha, beta, alpha, beta);
                if (aqlLtpdElements.efficiency) aqlLtpdElements.efficiency.value = (efficiency * 100).toFixed(1) + '%';
                if (aqlLtpdElements.aqlPa) aqlLtpdElements.aqlPa.value = (plan.paAql * 100).toFixed(1) + '%';
                if (aqlLtpdElements.ltpdPa) aqlLtpdElements.ltpdPa.value = (plan.paLtpd * 100).toFixed(1) + '%';
                if (aqlLtpdElements.actualAlpha) aqlLtpdElements.actualAlpha.value = (plan.actualAlpha * 100).toFixed(1) + '%';
                if (aqlLtpdElements.actualBeta) aqlLtpdElements.actualBeta.value = (plan.actualBeta * 100).toFixed(1) + '%';

                // Calculate additional metrics
                const aoql = calculateAOQL(plan.n, plan.c, aql / 100, lotSize, distribution);
                const asn = calculateASN(plan.n, plan.c, aql / 100, lotSize, distribution);
                
                if (aqlLtpdElements.aoql) aqlLtpdElements.aoql.value = (aoql * 100).toFixed(3) + '%';
                if (aqlLtpdElements.asn) aqlLtpdElements.asn.value = asn;
                
                // Calculate efficiency rating and improvement suggestions
                const { rating, suggestions } = calculateEfficiencyRatingAndSuggestions(plan, efficiency, alpha, beta, aql, ltpd, lotSize);
                if (aqlLtpdElements.efficiencyRating) aqlLtpdElements.efficiencyRating.value = rating;
                if (aqlLtpdElements.improvements) aqlLtpdElements.improvements.value = suggestions;

                // Update notes
                if (aqlLtpdElements.notes) {
                    aqlLtpdElements.notes.textContent = `Optimal plan calculated using ${optimization.replace('_', ' ')} strategy.`;
                }

                // Store plan and update chart
                aqlLtpdLastPlan = plan;
                updateAqlLtpdChart(plan);

            } catch (error) {
                if (aqlLtpdElements.errorDiv) {
                    aqlLtpdElements.errorDiv.textContent = error.message;
                    aqlLtpdElements.errorDiv.style.display = 'block';
                }
            }
        });
    }

    if (aqlLtpdElements.clearBtn) {
        aqlLtpdElements.clearBtn.addEventListener('click', function() {
            // Reset inputs to defaults
            if (aqlLtpdElements.aqlInput) aqlLtpdElements.aqlInput.value = '1.0';
            if (aqlLtpdElements.ltpdInput) aqlLtpdElements.ltpdInput.value = '5.0';
            if (aqlLtpdElements.lotSizeInput) aqlLtpdElements.lotSizeInput.value = '1000';
            if (aqlLtpdElements.distSelect) aqlLtpdElements.distSelect.value = 'binom';
            if (aqlLtpdElements.optimizationSelect) aqlLtpdElements.optimizationSelect.value = 'minimize_n';
            if (aqlLtpdElements.alphaInput) aqlLtpdElements.alphaInput.value = '0.05';
            if (aqlLtpdElements.betaInput) aqlLtpdElements.betaInput.value = '0.10';
            if (aqlLtpdElements.xMaxInput) aqlLtpdElements.xMaxInput.value = '10';

            // Clear results
            const resultElements = [aqlLtpdElements.resultN, aqlLtpdElements.resultC, aqlLtpdElements.efficiency,
                aqlLtpdElements.aqlPa, aqlLtpdElements.ltpdPa, aqlLtpdElements.actualAlpha, aqlLtpdElements.actualBeta,
                aqlLtpdElements.aoql, aqlLtpdElements.asn, aqlLtpdElements.efficiencyRating, aqlLtpdElements.improvements];
            resultElements.forEach(el => { if (el) el.value = '-'; });

            // Clear chart
            if (aqlLtpdChart) {
                aqlLtpdChart.destroy();
                aqlLtpdChart = null;
            }

            // Clear error and notes
            if (aqlLtpdElements.errorDiv) aqlLtpdElements.errorDiv.style.display = 'none';
            if (aqlLtpdElements.notes) aqlLtpdElements.notes.textContent = 'Enter AQL and LTPD values to calculate the optimal sampling plan.';

            aqlLtpdLastPlan = null;
        });
    }

    // X-axis max change handler
    if (aqlLtpdElements.xMaxInput) {
        aqlLtpdElements.xMaxInput.addEventListener('input', function() {
            if (aqlLtpdLastPlan) {
                updateAqlLtpdChart(aqlLtpdLastPlan);
            }
        });
    }

    // Export functionality
    if (aqlLtpdElements.exportPngBtn) {
        aqlLtpdElements.exportPngBtn.addEventListener('click', function() {
            if (aqlLtpdChart) {
                exportChartHiRes(aqlLtpdChart, 'aql_ltpd_balanced_plan');
            }
        });
    }

    if (aqlLtpdElements.exportCsvBtn) {
        aqlLtpdElements.exportCsvBtn.addEventListener('click', function() {
            if (aqlLtpdChart && aqlLtpdLastPlan) {
                let csv = 'x_defect_rate_percent,y_acceptance_prob,n,c,aql,ltpd,alpha,beta,distribution,optimization_target\n';
                aqlLtpdChart.data.datasets[0].data.forEach(point => {
                    csv += `${point.x},${point.y},${aqlLtpdLastPlan.n},${aqlLtpdLastPlan.c},${aqlLtpdElements.aqlInput?.value || 1},${aqlLtpdElements.ltpdInput?.value || 5},${aqlLtpdElements.alphaInput?.value || 0.05},${aqlLtpdElements.betaInput?.value || 0.10},${aqlLtpdElements.distSelect?.value || 'binom'},${aqlLtpdElements.optimizationSelect?.value || 'minimize_n'}\n`;
                });
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'aql_ltpd_balanced_plan.csv';
                a.click();
                URL.revokeObjectURL(url);
            }
        });
    }

    if (aqlLtpdElements.exportPlanBtn) {
        aqlLtpdElements.exportPlanBtn.addEventListener('click', function() {
            if (!aqlLtpdLastPlan) {
                alert('No plan to export. Please calculate first.');
                return;
            }
            window.planComparisonQueue = window.planComparisonQueue || [];
            const distName = aqlLtpdElements.distSelect?.value === 'hyper' ? 'Hypergeometric' : 
                           (aqlLtpdElements.distSelect?.value === 'pois' ? 'Poisson' : 'Binomial');
            const label = `AQL-LTPD n=${aqlLtpdLastPlan.n}, c=${aqlLtpdLastPlan.c} (${distName})`;
            window.planComparisonQueue.push({
                n: aqlLtpdLastPlan.n,
                c: aqlLtpdLastPlan.c,
                aql: parseFloat(aqlLtpdElements.aqlInput?.value || 1),
                label: label,
                dist: aqlLtpdElements.distSelect?.value || 'binom',
                N: parseInt(aqlLtpdElements.lotSizeInput?.value || 1000),
                // Include efficiency calculation data for consistent rating
                paAql: aqlLtpdLastPlan.paAql,
                paLtpd: aqlLtpdLastPlan.paLtpd,
                actualAlpha: aqlLtpdLastPlan.actualAlpha,
                actualBeta: aqlLtpdLastPlan.actualBeta,
                source: 'aql_ltpd'
            });
            alert('Plan exported to Multiple Plan Comparison queue.');
        });
    }

    // Initialize systems when page loads
    document.addEventListener('DOMContentLoaded', function() {
        initThemeSystem();
        initTutorial();
        initHelpSystem();
    });

    // ===== Unified Help System =====
    function initHelpSystem(){
        var helpModal = document.getElementById('help-modal');
        if (!helpModal){
            // create modal lazily if not present
            var wrap = document.createElement('div');
            wrap.id = 'help-modal';
            wrap.style.display = 'none';
            wrap.style.position = 'fixed';
            wrap.style.inset = '0';
            wrap.style.zIndex = '9999';
            wrap.style.alignItems = 'center';
            wrap.style.justifyContent = 'center';
            wrap.innerHTML = '\n                <div class="tutorial-overlay" style="position:absolute; inset:0; background:rgba(0,0,0,0.5);"></div>\n                <div class="tutorial-content" style="position:relative; max-width:900px; width:90%; background:var(--panel); border:1px solid var(--border); border-radius:12px; box-shadow:0 10px 40px rgba(0,0,0,0.35); overflow:hidden;">\n                    <div class="tutorial-header" style="display:flex; align-items:center; justify-content:space-between;">\n                        <h2 style="margin:0; font-size:1.3rem;">使用說明</h2>\n                        <div>\n                            <button class="btn" id="help-close-btn">Close</button>\n                        </div>\n                    </div>\n                    <div style="padding:18px 24px 8px; border-bottom:1px solid var(--border);">\n                        <div id="help-tabs" style="display:flex; gap:8px; flex-wrap:wrap;"></div>\n                    </div>\n                    <div id="help-content" style="padding:18px 24px; max-height:60vh; overflow:auto;"></div>\n                </div>';
            document.body.appendChild(wrap);
            helpModal = wrap;
        }
        var helpTabs = document.getElementById('help-tabs');
        var helpContent = document.getElementById('help-content');
        var closeBtn = document.getElementById('help-close-btn');
        var overlay = helpModal.querySelector('.tutorial-overlay');
        function close(){ helpModal.style.display='none'; document.body.style.overflow=''; }
        function open(){ helpModal.style.display='flex'; document.body.style.overflow='hidden'; }
        closeBtn && closeBtn.addEventListener('click', close);
        overlay && overlay.addEventListener('click', close);

        var helpData = {
            'distribution': {
                tabs: ['概述','輸入參數','輸出與圖表','使用時機'],
                sections: [
                    '<p>此頁用於比較超幾何、二項、卜瓦松三種分佈下，同一抽樣計畫的OC/AOQ/ATI行為。</p>',
                    '<ul><li>N: 批量大小 (Hypergeometric 必填)</li><li>n: 抽樣數</li><li>c: 可接受不良數</li><li>AQL(%): 可接受品質水準</li><li>x軸上限(%): 缺點率顯示範圍</li></ul>',
                    '<ul><li>OC曲線: y=Pa(接受機率)</li><li>AOQ曲線: 平均輸出品質(%)</li><li>ATI曲線: 平均總檢數</li><li>匯出: PNG/CSV</li></ul>',
                    '<ul><li>比較不同分佈假設的影響</li><li>想快速檢視AQL標記位置與曲線陡峭度</li></ul>'
                ]
            },
            'plan': {
                tabs: ['概述','輸入參數','輸出與圖表','使用時機'],
                sections: [
                    '<p>疊加多個抽樣計畫以視覺化比較OC/AOQ/ATI。</p>',
                    '<ul><li>n, c, AQL(%), 標籤、x軸上限</li></ul>',
                    '<ul><li>曲線清單與圖例、AQL標記</li><li>支援PNG/CSV、從各頁匯入</li></ul>',
                    '<ul><li>方案評比、向利害關係人展示差異</li></ul>'
                ]
            },
            'reverse': {
                tabs: ['概述','輸入參數','輸出與圖表','使用時機'],
                sections: [
                    '<p>固定三個參數，反解剩餘一個 (AQL、n、c、N、或目標Pa)。</p>',
                    '<ul><li>目標參數、N、n、c、AQL(%)、目標Pa(%)、分佈</li></ul>',
                    '<ul><li>計算所得計畫 (n,c) 與OC圖</li><li>可匯出至比較頁</li></ul>',
                    '<ul><li>當有既定風險點(如AQL95%)，想求合適n或c</li></ul>'
                ]
            },
            'kaiyi': {
                tabs: ['概述','輸入參數','輸出與圖表','使用時機'],
                sections: [
                    '<p>依 ANSI/ASQ Z1.4 進行AQL抽樣表查詢。</p>',
                    '<ul><li>N、AQL、檢驗水準、檢驗狀態(正常/放寬/加嚴)</li></ul>',
                    '<ul><li>輸出代碼字母、樣本量、Ac/Re、及在AQL的Pa/Pr/Pc</li><li>OC圖與匯出</li></ul>',
                    '<ul><li>需遵循標準抽樣制度時</li></ul>'
                ]
            },
            'c0': {
                tabs: ['概述','輸入參數','輸出與輸出','使用時機'],
                sections: [
                    '<p>查詢 C=0 (零接受) 抽樣表 (Squeglia)。</p>',
                    '<ul><li>N、AQL或自定AQL、分佈</li></ul>',
                    '<ul><li>輸出 n、c=0、對應LTPD@Pa=10% 等</li></ul>',
                    '<ul><li>高風險關鍵缺陷、嚴格把關場景</li></ul>'
                ]
            },
            'aql-ltpd': {
                tabs: ['概述','輸入參數','輸出與圖表','使用時機'],
                sections: [
                    '<p>同時滿足AQL與LTPD限制，透過數學最佳化找出計畫。</p>',
                    '<ul><li>AQL(%)、LTPD(%)、N、分佈、最佳化目標、α/β、x軸上限</li></ul>',
                    '<ul><li>輸出 n、c、效率分數、AOQL/ASN、OC圖與匯出</li></ul>',
                    '<ul><li>需在規格化兩端風險間取得平衡時</li></ul>'
                ]
            }
        };
        function renderHelp(kind){
            var data = helpData[kind] || helpData['distribution'];
            // tabs
            helpTabs.innerHTML = '';
            data.tabs.forEach(function(t,i){
                var b = document.createElement('button'); b.className='btn'+(i===0?' primary':''); b.textContent=t; b.addEventListener('click', function(){
                    Array.from(helpTabs.children).forEach(function(x){ x.classList.remove('primary'); }); b.classList.add('primary'); helpContent.innerHTML = data.sections[i];
                }); helpTabs.appendChild(b);
            });
            helpContent.innerHTML = data.sections[0] || '';
        }
        // bind triggers
        document.querySelectorAll('[data-help-for]').forEach(function(btn){
            btn.addEventListener('click', function(){ renderHelp(btn.getAttribute('data-help-for')); open(); });
        });
    }

    </script>
</body>
</html>


